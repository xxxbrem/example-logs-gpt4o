WITH track_stats AS (  -- overall statistics
    SELECT
        MIN("Milliseconds")      AS min_ms,
        AVG("Milliseconds")      AS avg_ms,
        MAX("Milliseconds")      AS max_ms
    FROM MUSIC.MUSIC."TRACK"
),
boundaries AS (        -- limits that define each length class
    SELECT
        min_ms,
        avg_ms,
        max_ms,
        (min_ms + avg_ms) / 2.0 AS mid1,      -- midpoint between min and average
        (avg_ms + max_ms) / 2.0 AS mid2       -- midpoint between average and max
    FROM track_stats
),
track_category AS (    -- assign every track to a length category
    SELECT
        t."TrackId",
        t."Milliseconds",
        CASE
            WHEN t."Milliseconds" < b.mid1           THEN 'Short'
            WHEN t."Milliseconds" < b.mid2           THEN 'Medium'
            ELSE                                         'Long'
        END AS length_category
    FROM MUSIC.MUSIC."TRACK" t
    CROSS JOIN boundaries b
),
track_revenue AS (     -- total revenue generated by each track
    SELECT
        il."TrackId",
        SUM(il."UnitPrice" * il."Quantity") AS revenue
    FROM MUSIC.MUSIC."INVOICELINE" il
    GROUP BY il."TrackId"
)
SELECT
    tc.length_category                              AS "LengthCategory",
    ROUND(MIN(tc."Milliseconds") / 60000.0, 4)      AS "MinMinutes",
    ROUND(MAX(tc."Milliseconds") / 60000.0, 4)      AS "MaxMinutes",
    ROUND(COALESCE(SUM(tr.revenue), 0), 4)          AS "TotalRevenue"
FROM track_category tc
LEFT JOIN track_revenue tr
       ON tc."TrackId" = tr."TrackId"
GROUP BY tc.length_category
ORDER BY tc.length_category;