2025-05-07 01:34:02 - Thread-28 (execute) - INFO - [Exploration]
```sql
--Description: 1) Peek at a few CPC-entries (as JSON) together with publication & filing dates
SELECT  t."publication_number",
        t."application_number",
        t."filing_date",
        t."cpc"
FROM    PATENTS.PATENTS.PUBLICATIONS t
WHERE   t."cpc" IS NOT NULL
LIMIT 20;
```

```sql
--Description: 2) Flatten the CPC array and show the first 20 raw CPC codes
SELECT  t."publication_number",
        f.value:"code"::STRING AS "cpc_code"
FROM    PATENTS.PATENTS.PUBLICATIONS t,
        LATERAL FLATTEN(input => t."cpc") f
LIMIT 20;
```

```sql
--Description: 3) Distinct CPC codes that really occur in the data together with their total occurrence count
SELECT  f.value:"code"::STRING AS "cpc_code",
        COUNT(*) AS "n_publications"
FROM    PATENTS.PATENTS.PUBLICATIONS t,
        LATERAL FLATTEN(input => t."cpc") f
GROUP BY 1
ORDER BY 2 DESC
LIMIT 20;
```

```sql
--Description: 4) Same flattening, but keep only patents with a non-empty application number and a valid filing date
SELECT  t."publication_number",
        t."application_number",
        t."filing_date",
        f.value:"code"::STRING AS "cpc_code"
FROM    PATENTS.PATENTS.PUBLICATIONS t,
        LATERAL FLATTEN(input => t."cpc") f
WHERE   t."application_number" IS NOT NULL
  AND   t."application_number" <> ''
  AND   t."filing_date"          IS NOT NULL
LIMIT 20;
```

```sql
--Description: 5) Look at the CPC definition table: sample rows with level, symbol and full title
SELECT  d."symbol",
        d."level",
        d."titleFull"
FROM    PATENTS.PATENTS.CPC_DEFINITION d
LIMIT 20;
```

```sql
--Description: 6) Fetch a few CPC groups at hierarchy level 5 together with their titles
SELECT  d."symbol"  AS "cpc_group_level5",
        d."titleFull"
FROM    PATENTS.PATENTS.CPC_DEFINITION d
WHERE   d."level" = 5
LIMIT 20;
```

```sql
--Description: 7) Join first CPC code of each publication to its level-5 group & show one sample row per publication
WITH first_cpc AS (
    SELECT  t."publication_number",
            t."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (PARTITION BY t."publication_number" ORDER BY f.index) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS t,
            LATERAL FLATTEN(input => t."cpc") f
    WHERE   t."application_number" IS NOT NULL
      AND   t."application_number" <> ''
      AND   t."filing_date" IS NOT NULL
)
SELECT  fc."publication_number",
        fc."filing_date",
        c5."symbol"        AS "cpc_group_level5",
        c5."titleFull"
FROM    first_cpc fc
JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc."cpc_code"
JOIN    PATENTS.PATENTS.CPC_DEFINITION c5        -- walk up to level-5 ancestor
           ON POSITION(c5."symbol", fc."cpc_code") = 1
          AND c5."level" = 5
WHERE   fc.rn = 1
LIMIT 20;
```

```sql
--Description: 8) Yearly filing counts per CPC level-5 group
WITH first_cpc AS (
    SELECT  t."publication_number",
            t."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (PARTITION BY t."publication_number" ORDER BY f.index) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS t,
            LATERAL FLATTEN(input => t."cpc") f
    WHERE   t."application_number" IS NOT NULL
      AND   t."application_number" <> ''
      AND   t."filing_date" IS NOT NULL
), pub2grp AS (
    SELECT  fc."publication_number",
            fc."filing_date",
            c5."symbol" AS "cpc_group_level5"
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
              ON cdef."symbol" = fc."cpc_code"
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
              ON POSITION(c5."symbol", fc."cpc_code") = 1
             AND c5."level" = 5
    WHERE   fc.rn = 1
), yearly AS (
    SELECT  cpc_group_level5,
            TO_NUMBER(SUBSTR(filing_date::STRING, 1, 4)) AS filing_year,
            COUNT(*) AS filings
    FROM    pub2grp
    GROUP BY 1,2
)
SELECT  *
FROM    yearly
ORDER BY 1,2
LIMIT 20;
```

```sql
--Description: 9) Compute the exponential moving average (α = 0.2) of yearly filings for one sample CPC group
WITH yearly AS (
    SELECT  TO_NUMBER(SUBSTR(t."filing_date"::STRING,1,4)) AS filing_year,
            COUNT(*) AS filings
    FROM    PATENTS.PATENTS.PUBLICATIONS t,
            LATERAL FLATTEN(input => t."cpc") f
    WHERE   f.value:"code"::STRING ILIKE 'H04L9/%'      -- sample CPC subtree
      AND   t."application_number" IS NOT NULL
      AND   t."application_number" <> ''
      AND   t."filing_date" IS NOT NULL
    GROUP BY 1
)
SELECT  filing_year,
        filings,
        EMA(filings, 0.2) OVER (ORDER BY filing_year) AS ema_0_2
FROM    yearly
ORDER BY 1
LIMIT 20;
```

```sql
--Description: 10) For all level-5 CPC groups, compute yearly filings & their EMA (α = 0.2), then pick the year with the highest EMA in each group
WITH first_cpc AS (
    SELECT  t."publication_number",
            t."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (PARTITION BY t."publication_number" ORDER BY f.index) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS t,
            LATERAL FLATTEN(input => t."cpc") f
    WHERE   t."application_number" IS NOT NULL
      AND   t."application_number" <> ''
      AND   t."filing_date" IS NOT NULL
), pub2grp AS (
    SELECT  fc."publication_number",
            TO_NUMBER(SUBSTR(fc."filing_date"::STRING,1,4)) AS filing_year,
            c5."symbol"  AS "cpc_group_level5",
            c5."titleFull"
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
              ON cdef."symbol" = fc."cpc_code"
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
              ON POSITION(c5."symbol", fc."cpc_code") = 1
             AND c5."level" = 5
    WHERE   fc.rn = 1
), yearly AS (
    SELECT  cpc_group_level5,
            titleFull,
            filing_year,
            COUNT(*) AS filings
    FROM    pub2grp
    GROUP BY 1,2,3
), yearly_with_ema AS (
    SELECT  cpc_group_level5,
            titleFull,
            filing_year,
            filings,
            EMA(filings,0.2) OVER (PARTITION BY cpc_group_level5 ORDER BY filing_year) AS ema_0_2
    FROM    yearly
)
SELECT  *
FROM (
    SELECT  cpc_group_level5,
            titleFull,
            filing_year  AS best_year,
            ema_0_2      AS best_ema,
            ROW_NUMBER() OVER (PARTITION BY cpc_group_level5 ORDER BY ema_0_2 DESC) AS rn
    FROM    yearly_with_ema
) q
WHERE   rn = 1
ORDER BY best_ema DESC
LIMIT 20;
```
[Exploration]
2025-05-07 01:34:02 - Thread-28 (execute) - INFO - [Try to execute]
--Description: 1) Peek at a few CPC-entries (as JSON) together with publication & filing dates
SELECT  t."publication_number",
        t."application_number",
        t."filing_date",
        t."cpc"
FROM    PATENTS.PATENTS.PUBLICATIONS t
WHERE   t."cpc" IS NOT NULL
LIMIT 20;
[Try to execute]
2025-05-07 01:34:04 - Thread-28 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
--Description: 1) Peek at a few CPC-entries (as JSON) together with publication & filing dates
SELECT  t."publication_number",
        t."application_number",
        t."filing_date",
        t."cpc"
FROM    PATENTS.PATENTS.PUBLICATIONS t
WHERE   t."cpc" IS NOT NULL
LIMIT 20;
Results:
publication_number,application_number,filing_date,cpc
CN-2384262-Y,CN-99220041-U,19990304,[]
CN-2368443-Y,CN-99223233-U,19990325,[]
CN-2375662-Y,CN-99231678-U,19990524,[]
CN-2385653-Y,CN-99236750-U,19990727,[]
CN-2382415-Y,CN-99238338-U,19990817,[]
CN-2405417-Y,CN-99258085-U,19991228,[]
ES-1070067-Y,ES-200900212-U,20090209,[]
GR-2001887-Y,GR-960200239-U,19961003,[]
CN-2649912-Y,CN-200320103967-U,20031103,[]
CN-2663940-Y,CN-200320104650-U,20031226,[]
CN-2669819-Y,CN-200320107671-U,2003

[Successfully executed]
2025-05-07 01:34:04 - Thread-28 (execute) - INFO - [Try to execute]
--Description: 2) Flatten the CPC array and show the first 20 raw CPC codes
SELECT  t."publication_number",
        f.value:"code"::STRING AS "cpc_code"
FROM    PATENTS.PATENTS.PUBLICATIONS t,
        LATERAL FLATTEN(input => t."cpc") f
LIMIT 20;
[Try to execute]
2025-05-07 01:34:04 - Thread-28 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
--Description: 2) Flatten the CPC array and show the first 20 raw CPC codes
SELECT  t."publication_number",
        f.value:"code"::STRING AS "cpc_code"
FROM    PATENTS.PATENTS.PUBLICATIONS t,
        LATERAL FLATTEN(input => t."cpc") f
LIMIT 20;
Results:
publication_number,cpc_code
HK-6083-A,H02M5/00
HU-T52763-A,A01N47/36
HU-T52763-A,C07D521/00
JP-H03206829-A,Y02A40/81
JP-S62159089-A,Y02E30/30
US-416-A,Y10T83/465
US-416-A,B26F1/42
US-2528225-A,E21B27/02
US-2528225-A,E21B27/02
AT-A41580-A,B22D11/086
AT-A47682-A,C07D471/16
AT-A47682-A,C07D471/22
AT-A63682-A,G01N33/48728
CA-920790-A,C03C4/12
CA-920790-A,C03C4/12
CA-950907-A,C11B5/0064
CA-950907-A,C08K5/35
CA-950907-A,C11B5/0035

[Successfully executed]
2025-05-07 01:34:04 - Thread-28 (execute) - INFO - [Try to execute]
--Description: 3) Distinct CPC codes that really occur in the data together with their total occurrence count
SELECT  f.value:"code"::STRING AS "cpc_code",
        COUNT(*) AS "n_publications"
FROM    PATENTS.PATENTS.PUBLICATIONS t,
        LATERAL FLATTEN(input => t."cpc") f
GROUP BY 1
ORDER BY 2 DESC
LIMIT 20;
[Try to execute]
2025-05-07 01:34:06 - Thread-28 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
--Description: 3) Distinct CPC codes that really occur in the data together with their total occurrence count
SELECT  f.value:"code"::STRING AS "cpc_code",
        COUNT(*) AS "n_publications"
FROM    PATENTS.PATENTS.PUBLICATIONS t,
        LATERAL FLATTEN(input => t."cpc") f
GROUP BY 1
ORDER BY 2 DESC
LIMIT 20;
Results:
cpc_code,n_publications
Y02E60/10,5576
A61P35/00,5514
A61P43/00,3803
A61K45/06,3065
Y02P70/50,2621
A61P29/00,2555
A61K38/00,2489
A61P25/00,2136
A61K2039/505,1915
Y02T10/12,1834
Y02E10/50,1825
A23V2002/00,1817
Y02T10/70,1777
C07D471/04,1747
H01L2924/0002,1714
A61P25/28,1694
Y02E60/50,1668
Y02A50/30,1659
H01M10/0525,1650
Y02D30/70,1618

[Successfully executed]
2025-05-07 01:34:06 - Thread-28 (execute) - INFO - [Try to execute]
--Description: 4) Same flattening, but keep only patents with a non-empty application number and a valid filing date
SELECT  t."publication_number",
        t."application_number",
        t."filing_date",
        f.value:"code"::STRING AS "cpc_code"
FROM    PATENTS.PATENTS.PUBLICATIONS t,
        LATERAL FLATTEN(input => t."cpc") f
WHERE   t."application_number" IS NOT NULL
  AND   t."application_number" <> ''
  AND   t."filing_date"          IS NOT NULL
LIMIT 20;
[Try to execute]
2025-05-07 01:34:06 - Thread-28 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
--Description: 4) Same flattening, but keep only patents with a non-empty application number and a valid filing date
SELECT  t."publication_number",
        t."application_number",
        t."filing_date",
        f.value:"code"::STRING AS "cpc_code"
FROM    PATENTS.PATENTS.PUBLICATIONS t,
        LATERAL FLATTEN(input => t."cpc") f
WHERE   t."application_number" IS NOT NULL
  AND   t."application_number" <> ''
  AND   t."filing_date"          IS NOT NULL
LIMIT 20;
Results:
publication_number,application_number,filing_date,cpc_code
WO-2017120317-A1,US-2017012308-W,20170105,B01L3/502753
WO-2017120317-A1,US-2017012308-W,20170105,B01L2300/0864
WO-2017120317-A1,US-2017012308-W,20170105,B01L2200/0647
WO-2017120317-A1,US-2017012308-W,20170105,G01N33/491
WO-2017120317-A1,US-2017012308-W,20170105,B01L2300/0864
WO-2017120317-A1,US-2017012308-W,20170105,B01L2300/0627
WO-2017120317-A1,US-2017012308-W,20170105,B01L3/502746
WO-2017120317-A1,US-2017012308-W,20170105,G01N

[Successfully executed]
2025-05-07 01:34:06 - Thread-28 (execute) - INFO - [Try to execute]
--Description: 5) Look at the CPC definition table: sample rows with level, symbol and full title
SELECT  d."symbol",
        d."level",
        d."titleFull"
FROM    PATENTS.PATENTS.CPC_DEFINITION d
LIMIT 20;
[Try to execute]
2025-05-07 01:34:07 - Thread-28 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
--Description: 5) Look at the CPC definition table: sample rows with level, symbol and full title
SELECT  d."symbol",
        d."level",
        d."titleFull"
FROM    PATENTS.PATENTS.CPC_DEFINITION d
LIMIT 20;
Results:
symbol,level,titleFull
B,2.0,PERFORMING OPERATIONS; TRANSPORTING
H,2.0,ELECTRICITY
Y,2.0,GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
D,2.0,TEXTILES; PAPER
F,2.0,MECHANICAL ENGINEERING; LIGHTING; HEATING; WEAPONS; BLASTING
E,2.0,FIXED CONSTRUCTIONS
C,2.0,CHEMISTRY; METALLURGY
G,2.0,PHYSICS

[Successfully executed]
2025-05-07 01:34:07 - Thread-28 (execute) - INFO - [Try to execute]
--Description: 6) Fetch a few CPC groups at hierarchy level 5 together with their titles
SELECT  d."symbol"  AS "cpc_group_level5",
        d."titleFull"
FROM    PATENTS.PATENTS.CPC_DEFINITION d
WHERE   d."level" = 5
LIMIT 20;
[Try to execute]
2025-05-07 01:34:07 - Thread-28 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
--Description: 6) Fetch a few CPC groups at hierarchy level 5 together with their titles
SELECT  d."symbol"  AS "cpc_group_level5",
        d."titleFull"
FROM    PATENTS.PATENTS.CPC_DEFINITION d
WHERE   d."level" = 5
LIMIT 20;
Results:
cpc_group_level5,titleFull
A01H,NEW PLANTS OR NON-TRANSGENIC PROCESSES FOR OBTAINING THEM; PLANT REPRODUCTION BY TISSUE CULTURE TECHNIQUES
A01F,PROCESSING OF HARVESTED PRODUCE; HAY OR STRAW PRESSES; DEVICES FOR STORING AGRICULTURAL OR HORTICULTURAL PRODUCE
A01C,PLANTING; SOWING; FERTILISING
A01G,"HORTICULTURE; CULTIVATION OF VEGETABLES, FLOWERS, RICE, FRUIT, VINES, HOPS OR SEAWEED; FORESTRY; WATERING"
A01N,"PRESERVATION OF BODIES OF HUMANS OR ANIMALS OR PLANTS OR PARTS THEREOF; BIOCIDES, e.

[Successfully executed]
2025-05-07 01:34:07 - Thread-28 (execute) - INFO - [Try to execute]
--Description: 7) Join first CPC code of each publication to its level-5 group & show one sample row per publication
WITH first_cpc AS (
    SELECT  t."publication_number",
            t."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (PARTITION BY t."publication_number" ORDER BY f.index) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS t,
            LATERAL FLATTEN(input => t."cpc") f
    WHERE   t."application_number" IS NOT NULL
      AND   t."application_number" <> ''
      AND   t."filing_date" IS NOT NULL
)
SELECT  fc."publication_number",
        fc."filing_date",
        c5."symbol"        AS "cpc_group_level5",
        c5."titleFull"
FROM    first_cpc fc
JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc."cpc_code"
JOIN    PATENTS.PATENTS.CPC_DEFINITION c5        -- walk up to level-5 ancestor
           ON POSITION(c5."symbol", fc."cpc_code") = 1
          AND c5."level" = 5
WHERE   fc.rn = 1
LIMIT 20;
[Try to execute]
2025-05-07 01:34:09 - Thread-28 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
--Description: 7) Join first CPC code of each publication to its level-5 group & show one sample row per publication
WITH first_cpc AS (
    SELECT  t."publication_number",
            t."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (PARTITION BY t."publication_number" ORDER BY f.index) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS t,
            LATERAL FLATTEN(input => t."cpc") f
    WHERE   t."application_number" IS NOT NULL
      AND   t."application_number" <> ''
      AND   t."filing_date" IS NOT NULL
)
SELECT  fc."publication_number",
        fc."filing_date",
        c5."symbol"        AS "cpc_group_level5",
        c5."titleFull"
FROM    first_cpc fc
JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc."cpc_code"
JOIN    PATENTS.PATENTS.CPC_DEFINITION c5        -- walk up to level-5 ancestor
           ON POSITION(c5."symbol", fc."cpc_code") = 1
          AND c5."level" = 5
WHERE   fc.rn = 1
LIMIT 20;
Results:
publication_number,filing_date,cpc_group_level5,titleFull
CN-115143231-A,20220727,F16F,SPRINGS; SHOCK-ABSORBERS; MEANS FOR DAMPING VIBRATION
JP-2013247671-A,20121226,H01L,SEMICONDUCTOR DEVICES NOT COVERED BY CLASS H10
US-8862771-B2,20081220,H04L,"TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION"
JP-2020006907-A,20180712,F16F,SPRINGS; SHOCK-ABSORBERS; MEANS FOR DAMPING VIBRATION
AT-E226854-T1,19950505,G01N,INVESTIGATING OR ANALYSING MATERIALS BY DETERMINING THEIR CHEMICAL 

[Successfully executed]
2025-05-07 01:34:09 - Thread-28 (execute) - INFO - [Try to execute]
--Description: 8) Yearly filing counts per CPC level-5 group
WITH first_cpc AS (
    SELECT  t."publication_number",
            t."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (PARTITION BY t."publication_number" ORDER BY f.index) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS t,
            LATERAL FLATTEN(input => t."cpc") f
    WHERE   t."application_number" IS NOT NULL
      AND   t."application_number" <> ''
      AND   t."filing_date" IS NOT NULL
), pub2grp AS (
    SELECT  fc."publication_number",
            fc."filing_date",
            c5."symbol" AS "cpc_group_level5"
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
              ON cdef."symbol" = fc."cpc_code"
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
              ON POSITION(c5."symbol", fc."cpc_code") = 1
             AND c5."level" = 5
    WHERE   fc.rn = 1
), yearly AS (
    SELECT  cpc_group_level5,
            TO_NUMBER(SUBSTR(filing_date::STRING, 1, 4)) AS filing_year,
            COUNT(*) AS filings
    FROM    pub2grp
    GROUP BY 1,2
)
SELECT  *
FROM    yearly
ORDER BY 1,2
LIMIT 20;
[Try to execute]
2025-05-07 01:34:09 - Thread-28 (execute) - INFO - [Error occurred]
{'status': 'error', 'error_msg': "##ERROR##000904 (42000): SQL compilation error: error line 23 at position 12\ninvalid identifier 'CPC_GROUP_LEVEL5'"}
[Error occurred]
2025-05-07 01:36:07 - Thread-28 (execute) - INFO - [Corrected SQL]
```sql
--Description: We need yearly filing counts per CPC level-5 group.
--  • first_cpc : keep only the FIRST CPC code for every publication that has
--                a non-empty application number and non-null filing date.
--  • pub2grp   : map that first CPC code to its ancestor group whose
--                definition row is at hierarchy LEVEL = 5.  Because every
--                descendant code starts with its ancestor’s symbol, we can
--                identify the ancestor via POSITION(c5.symbol , fc.cpc_code)=1.
--  • yearly    : aggregate counts per ("cpc_group_level5", year).  All quoted
--                identifiers are case-sensitive, so we wrap them in double
--                quotes to avoid the previous “invalid identifier” error.
WITH first_cpc AS (
    SELECT  p."publication_number",
            p."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (PARTITION BY p."publication_number" ORDER BY f.index) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS p,
            LATERAL FLATTEN(input => p."cpc") f
    WHERE   p."application_number" IS NOT NULL
      AND   p."application_number" <> ''
      AND   p."filing_date" IS NOT NULL
), pub2grp AS (
    SELECT  fc."publication_number",
            fc."filing_date",
            c5."symbol" AS "cpc_group_level5"
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc."cpc_code"
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
           ON POSITION(c5."symbol", fc."cpc_code") = 1
          AND c5."level" = 5
    WHERE   fc.rn = 1
), yearly AS (
    SELECT  "cpc_group_level5",
            TO_NUMBER(SUBSTR("filing_date"::STRING, 1, 4)) AS filing_year,
            COUNT(*) AS filings
    FROM    pub2grp
    GROUP BY 1, 2
)
SELECT  *
FROM    yearly
ORDER BY 1, 2
LIMIT 20;
```
[Corrected SQL]
2025-05-07 01:37:42 - Thread-28 (execute) - INFO - [Results for corrected sql]
cpc_group_level5,FILING_YEAR,FILINGS
A01B,0,52
A01B,1901,2
A01B,1902,2
A01B,1904,1
A01B,1905,1
A01B,1906,1
A01B,1908,1
A01B,1911,2
A01B,1912,1
A01B,1913,3
A01B,1916,1
A01B,1917,1
A01B,1918,3
A01B,1919,1
A01B,1920,1
A01B,1922,1
A01B,1925,1
A01B,1926,3
A01B,1927,1
A01B,1931,1

[Results for corrected sql]
2025-05-07 01:38:02 - Thread-28 (execute) - INFO - [Corrected other sqls]
```sql
--Description: 9) Compute the exponential moving average (α = 0.2) of yearly
--             filings inside one CPC subtree (codes that start with “H04L9/”).
WITH yearly AS (
    SELECT  TO_NUMBER(SUBSTR(t."filing_date"::STRING, 1, 4)) AS filing_year,
            COUNT(*) AS filings
    FROM    PATENTS.PATENTS.PUBLICATIONS t,
            LATERAL FLATTEN(input => t."cpc") f
    WHERE   f.value:"code"::STRING ILIKE 'H04L9/%'      -- sample CPC subtree
      AND   t."application_number" IS NOT NULL
      AND   t."application_number" <> ''
      AND   t."filing_date" IS NOT NULL
    GROUP BY 1
)
SELECT  filing_year,
        filings,
        EMA(filings, 0.2) OVER (ORDER BY filing_year) AS ema_0_2
FROM    yearly
ORDER BY 1
LIMIT 20;
```

```sql
--Description: 10) For ALL level-5 CPC groups: compute yearly filings, their
--              EMA (α = 0.2), and keep the year where that EMA peaks.
WITH first_cpc AS (
    SELECT  t."publication_number",
            t."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (PARTITION BY t."publication_number" ORDER BY f.index) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS t,
            LATERAL FLATTEN(input => t."cpc") f
    WHERE   t."application_number" IS NOT NULL
      AND   t."application_number" <> ''
      AND   t."filing_date" IS NOT NULL
), pub2grp AS (
    SELECT  fc."publication_number",
            TO_NUMBER(SUBSTR(fc."filing_date"::STRING, 1, 4)) AS filing_year,
            c5."symbol"     AS "cpc_group_level5",
            c5."titleFull"  AS "titleFull"
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc."cpc_code"
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
           ON POSITION(c5."symbol", fc."cpc_code") = 1
          AND c5."level" = 5
    WHERE   fc.rn = 1
), yearly AS (
    SELECT  "cpc_group_level5",
            "titleFull",
            filing_year,
            COUNT(*) AS filings
    FROM    pub2grp
    GROUP BY 1, 2, 3
), yearly_with_ema AS (
    SELECT  "cpc_group_level5",
            "titleFull",
            filing_year,
            filings,
            EMA(filings, 0.2) OVER (
                PARTITION BY "cpc_group_level5"
                ORDER BY       filing_year
            ) AS ema_0_2
    FROM    yearly
), ranked AS (
    SELECT  "cpc_group_level5",
            "titleFull",
            filing_year  AS best_year,
            ema_0_2      AS best_ema,
            ROW_NUMBER() OVER (
                PARTITION BY "cpc_group_level5"
                ORDER BY     ema_0_2 DESC
            ) AS rn
    FROM    yearly_with_ema
)
SELECT  "cpc_group_level5",
        "titleFull",
        best_year,
        best_ema
FROM    ranked
WHERE   rn = 1
ORDER BY best_ema DESC
LIMIT 20;
```
[Corrected other sqls]
2025-05-07 01:38:02 - Thread-28 (execute) - INFO - [Successfully corrected]
Successfully corrected. SQL:
--Description: We need yearly filing counts per CPC level-5 group.
--  • first_cpc : keep only the FIRST CPC code for every publication that has
--                a non-empty application number and non-null filing date.
--  • pub2grp   : map that first CPC code to its ancestor group whose
--                definition row is at hierarchy LEVEL = 5.  Because every
--                descendant code starts with its ancestor’s symbol, we can
--                identify the ancestor via POSITION(c5.symbol , fc.cpc_code)=1.
--  • yearly    : aggregate counts per ("cpc_group_level5", year).  All quoted
--                identifiers are case-sensitive, so we wrap them in double
--                quotes to avoid the previous “invalid identifier” error.
WITH first_cpc AS (
    SELECT  p."publication_number",
            p."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (PARTITION BY p."publication_number" ORDER BY f.index) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS p,
            LATERAL FLATTEN(input => p."cpc") f
    WHERE   p."application_number" IS NOT NULL
      AND   p."application_number" <> ''
      AND   p."filing_date" IS NOT NULL
), pub2grp AS (
    SELECT  fc."publication_number",
            fc."filing_date",
            c5."symbol" AS "cpc_group_level5"
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc."cpc_code"
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
           ON POSITION(c5."symbol", fc."cpc_code") = 1
          AND c5."level" = 5
    WHERE   fc.rn = 1
), yearly AS (
    SELECT  "cpc_group_level5",
            TO_NUMBER(SUBSTR("filing_date"::STRING, 1, 4)) AS filing_year,
            COUNT(*) AS filings
    FROM    pub2grp
    GROUP BY 1, 2
)
SELECT  *
FROM    yearly
ORDER BY 1, 2
LIMIT 20;
Results:
cpc_group_level5,FILING_YEAR,FILINGS
A01B,0,52
A01B,1901,2
A01B,1902,2
A01B,1904,1
A01B,1905,1
A01B,1906,1
A01B,1908,1
A01B,1911,2
A01B,1912,1
A01B,1913,3
A01B,1916,1
A01B,1917,1
A01B,1918,3
A01B,1919,1
A01B,1920,1
A01B,1922,1
A01B,1925,1
A01B,1926,3
A01B,1927,1
A01B,1931,1

[Successfully corrected]
2025-05-07 01:38:02 - Thread-28 (execute) - INFO - [Try to execute]
--Description: 9) Compute the exponential moving average (α = 0.2) of yearly
--             filings inside one CPC subtree (codes that start with “H04L9/”).
WITH yearly AS (
    SELECT  TO_NUMBER(SUBSTR(t."filing_date"::STRING, 1, 4)) AS filing_year,
            COUNT(*) AS filings
    FROM    PATENTS.PATENTS.PUBLICATIONS t,
            LATERAL FLATTEN(input => t."cpc") f
    WHERE   f.value:"code"::STRING ILIKE 'H04L9/%'      -- sample CPC subtree
      AND   t."application_number" IS NOT NULL
      AND   t."application_number" <> ''
      AND   t."filing_date" IS NOT NULL
    GROUP BY 1
)
SELECT  filing_year,
        filings,
        EMA(filings, 0.2) OVER (ORDER BY filing_year) AS ema_0_2
FROM    yearly
ORDER BY 1
LIMIT 20
[Try to execute]
2025-05-07 01:38:02 - Thread-28 (execute) - INFO - [Error occurred]
{'status': 'error', 'error_msg': '##ERROR##002060 (42601): SQL compilation error:\nInvalid function type [EMA] for window function.'}
[Error occurred]
2025-05-07 01:40:45 - Thread-28 (execute) - INFO - [Corrected SQL]
```sql
--Description:  Identify, for every CPC technology area at hierarchy LEVEL = 5,
--              the calendar year in which its exponential–moving-average (α = 0.2)
--              of patent-filing counts reaches the maximum.  Because Snowflake
--              lacks a native EMA window function, the EMA is implemented with
--              a recursive CTE.
--              ────────────────────────────────────────────────────────────────
--   1) first_cpc  – For each publication keep only its FIRST CPC code when the
--      publication has (a) non-empty application number and (b) a filing date.
--   2) pub2grp    – Map that CPC code to its ancestor CPC group whose
--      definition row is at LEVEL = 5 (e.g. “H04L”).  We rely on the fact that
--      every descendant symbol begins with its ancestor’s symbol, so
--      POSITION(c5.symbol , fc.cpc_code)=1 does the ancestry check.
--   3) yearly     – Count filings per (group, year).
--   4) ordered    – Attach a row number per group to enforce chronological
--      order (needed for the recursive EMA).
--   5) ema_cte    – Recursively calculate the EMA inside each group:
--          ema₁ = filings₁
--          emaₜ = 0.2 · filingsₜ + 0.8 · emaₜ₋₁
--   6) best_year  – Per group, select the year where its EMA peaks.
--   The final result shows the CPC symbol, its full title, that “best year,”
--   and the peak EMA value, sorted by descending EMA (momentum).  Only the top
--   20 groups are displayed.
WITH first_cpc AS (  ----------------------------------------------------- Step 1
    SELECT  p."publication_number",
            p."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (PARTITION BY p."publication_number" ORDER BY f.index) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS p,
            LATERAL FLATTEN(input => p."cpc") f
    WHERE   p."application_number" IS NOT NULL
      AND   p."application_number" <> ''
      AND   p."filing_date" IS NOT NULL
),
pub2grp AS (       -------------------------------------------------------- Step 2
    SELECT  fc."publication_number",
            fc."filing_date",
            c5."symbol"     AS "cpc_group_level5",
            c5."titleFull"  AS "cpc_title"
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc."cpc_code"
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
           ON POSITION(c5."symbol", fc."cpc_code") = 1
          AND c5."level" = 5
    WHERE   fc.rn = 1
),
yearly AS (        -------------------------------------------------------- Step 3
    SELECT  "cpc_group_level5",
            "cpc_title",
            TO_NUMBER(SUBSTR("filing_date"::STRING, 1, 4)) AS filing_year,
            COUNT(*)::FLOAT AS filings
    FROM    pub2grp
    GROUP BY 1,2,3
),
ordered AS (       -------------------------------------------------------- Step 4
    SELECT  *,
            ROW_NUMBER() OVER (
                PARTITION BY "cpc_group_level5"
                ORDER BY     filing_year
            ) AS rn
    FROM    yearly
),
RECURSIVE ema_cte AS ( ---------------------------------------------------- Step 5
    -- Seed: first year of each CPC group
    SELECT  "cpc_group_level5",
            "cpc_title",
            filing_year,
            filings,
            filings        AS ema_0_2,
            rn
    FROM    ordered
    WHERE   rn = 1
    UNION ALL
    -- Recursive EMA
    SELECT  o."cpc_group_level5",
            o."cpc_title",
            o.filing_year,
            o.filings,
            0.2 * o.filings + 0.8 * e.ema_0_2  AS ema_0_2,
            o.rn
    FROM    ema_cte e
    JOIN    ordered o
           ON o."cpc_group_level5" = e."cpc_group_level5"
          AND o.rn = e.rn + 1
),
best_year AS (     -------------------------------------------------------- Step 6
    SELECT  "cpc_group_level5",
            "cpc_title",
            filing_year   AS best_year,
            ema_0_2       AS best_ema,
            ROW_NUMBER() OVER (
                PARTITION BY "cpc_group_level5"
                ORDER BY     ema_0_2 DESC
            ) AS rk
    FROM    ema_cte
)
SELECT  "cpc_group_level5",
        "cpc_title",
        best_year,
        best_ema
FROM    best_year
WHERE   rk = 1
ORDER BY best_ema DESC
LIMIT 20;
```
[Corrected SQL]
2025-05-07 01:40:45 - Thread-28 (execute) - INFO - [Results for corrected sql]
{'status': 'error', 'error_msg': "##ERROR##001003 (42000): SQL compilation error:\nsyntax error line 41 at position 10 unexpected 'ema_cte'."}
[Results for corrected sql]
2025-05-07 01:43:59 - Thread-28 (execute) - INFO - [Corrected SQL]
```sql
--Description:  Identify, for every CPC technology group at hierarchy LEVEL = 5,
--              the calendar year in which its exponential-moving-average
--              (α = 0.2) of patent-filing counts peaks.  Snowflake lacks a
--              built-in EMA window function, so we implement the EMA by means
--              of a recursive CTE.
--              ----------------------------------------------------------------
-- 1) first_cpc  – keep only the FIRST CPC code of each publication that has
--    both a non-empty application number and a filing date.
-- 2) pub2grp    – map that CPC code to its ancestor CPC group whose
--    CPC-DEFINITION row is at LEVEL = 5 (e.g. “H04L”).
-- 3) yearly     – count filings per (group, year).
-- 4) ordered    – assign a row number per group to guarantee chronological
--    ordering (needed for recursion).
-- 5) ema_cte    – recursively calculate the EMA within each group:
--       ema₁ = filings₁
--       emaₜ = 0.2 · filingsₜ + 0.8 · emaₜ₋₁
-- 6) best_year  – per group, keep the year where its EMA reaches the maximum.
WITH first_cpc AS (                                                        -- 1
    SELECT  p."publication_number",
            p."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (
                PARTITION BY p."publication_number"
                ORDER BY     f.index
            ) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS p,
            LATERAL FLATTEN(input => p."cpc") f
    WHERE   p."application_number" IS NOT NULL
      AND   p."application_number" <> ''
      AND   p."filing_date" IS NOT NULL
),
pub2grp AS (                                                               -- 2
    SELECT  fc."publication_number",
            fc."filing_date",
            c5."symbol"     AS "cpc_group_level5",
            c5."titleFull"  AS "cpc_title"
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc."cpc_code"
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
           ON POSITION(c5."symbol", fc."cpc_code") = 1
          AND c5."level" = 5
    WHERE   fc.rn = 1
),
yearly AS (                                                                 -- 3
    SELECT  "cpc_group_level5",
            "cpc_title",
            TO_NUMBER(SUBSTR("filing_date"::STRING,1,4)) AS filing_year,
            COUNT(*)::FLOAT AS filings
    FROM    pub2grp
    GROUP BY 1,2,3
),
ordered AS (                                                                -- 4
    SELECT  *,
            ROW_NUMBER() OVER (
                PARTITION BY "cpc_group_level5"
                ORDER BY     filing_year
            ) AS rn
    FROM    yearly
),
RECURSIVE ema_cte (cpc_group_level5, cpc_title, filing_year,
                   filings, ema_0_2, rn) AS (                              -- 5
    -- Anchor (first year of every CPC group)
    SELECT  "cpc_group_level5",
            "cpc_title",
            filing_year,
            filings,
            filings AS ema_0_2,
            rn
    FROM    ordered
    WHERE   rn = 1
    UNION ALL
    -- Recursive EMA step
    SELECT  o."cpc_group_level5",
            o."cpc_title",
            o.filing_year,
            o.filings,
            0.2 * o.filings + 0.8 * e.ema_0_2 AS ema_0_2,
            o.rn
    FROM    ema_cte e
    JOIN    ordered o
           ON o."cpc_group_level5" = e."cpc_group_level5"
          AND o.rn = e.rn + 1
),
best_year AS (                                                              -- 6
    SELECT  cpc_group_level5,
            cpc_title,
            filing_year AS best_year,
            ema_0_2     AS best_ema,
            ROW_NUMBER() OVER (
                PARTITION BY cpc_group_level5
                ORDER BY     ema_0_2 DESC
            ) AS rk
    FROM    ema_cte
)
SELECT  cpc_group_level5,
        cpc_title,
        best_year,
        best_ema
FROM    best_year
WHERE   rk = 1
ORDER BY best_ema DESC
LIMIT 20;
```
[Corrected SQL]
2025-05-07 01:44:00 - Thread-28 (execute) - INFO - [Results for corrected sql]
{'status': 'error', 'error_msg': "##ERROR##001003 (42000): SQL compilation error:\nsyntax error line 44 at position 10 unexpected 'ema_cte'.\nsyntax error line 44 at position 19 unexpected 'cpc_group_level5'.\nsyntax error line 45 at position 41 unexpected 'AS'."}
[Results for corrected sql]
2025-05-07 01:46:44 - Thread-28 (execute) - INFO - [Corrected SQL]
```sql
--Description:  For the CPC subtree “H04L9/” (cryptographic aspects of digital
--              communication), compute yearly patent-filing counts and then an
--              exponential moving average (EMA) with smoothing factor α = 0.2.
--              Snowflake lacks a native EMA function, so we build it manually
--              using a recursive CTE:
--              • yearly   – counts per calendar year.
--              • ordered  – attach row numbers to force chronological order.
--              • ema_cte  – recursive EMA:  ema₁ = value₁ ;  emaₜ = 0.2·vₜ + 0.8·emaₜ₋₁.
--              The final result lists (year, filings, EMA) for the first
--              20 years in ascending order.
WITH RECURSIVE
/* 1 ─ Yearly filing counts ------------------------------------------------- */
yearly AS (
    SELECT  TO_NUMBER(SUBSTR(p."filing_date"::STRING, 1, 4)) AS filing_year,
            COUNT(*)::FLOAT                                   AS filings
    FROM    PATENTS.PATENTS.PUBLICATIONS       p,
            LATERAL FLATTEN(input => p."cpc")  f
    WHERE   f.value:"code"::STRING ILIKE 'H04L9/%'            -- target subtree
      AND   p."application_number" IS NOT NULL
      AND   p."application_number" <> ''
      AND   p."filing_date" IS NOT NULL
    GROUP BY 1
),
/* 2 ─ Impose chronological order ------------------------------------------ */
ordered AS (
    SELECT  filing_year,
            filings,
            ROW_NUMBER() OVER (ORDER BY filing_year) AS rn
    FROM    yearly
),
/* 3 ─ Recursive EMA calculation ------------------------------------------- */
ema_cte (filing_year, filings, ema_0_2, rn) AS (
    -- Anchor row (first year): EMA equals the first value
    SELECT  filing_year,
            filings,
            filings AS ema_0_2,
            rn
    FROM    ordered
    WHERE   rn = 1
    UNION ALL
    -- Recursive step: emaₜ = 0.2·valueₜ + 0.8·emaₜ₋₁
    SELECT  o.filing_year,
            o.filings,
            0.2 * o.filings + 0.8 * e.ema_0_2,
            o.rn
    FROM    ema_cte e
    JOIN    ordered o
           ON o.rn = e.rn + 1
)
/* ─────────────────────────────────────────────────────────────────────────── */
SELECT  filing_year,
        filings,
        ema_0_2
FROM    ema_cte
ORDER BY filing_year
LIMIT 20;
```
[Corrected SQL]
2025-05-07 01:48:50 - Thread-28 (execute) - INFO - [Results for corrected sql]
FILING_YEAR,FILINGS,EMA_0_2
1954,1.0,1.0
1967,6.0,2.0
1976,4.0,2.4000000000000004
1978,4.0,2.7200000000000006
1983,4.0,2.976000000000001
1984,1.0,2.580800000000001
1985,3.0,2.664640000000001
1986,3.0,2.731712000000001
1987,2.0,2.585369600000001
1989,4.0,2.868295680000001
1990,7.0,3.6946365440000006
1991,4.0,3.7557092352000003
1992,15.0,6.00456738816
1993,5.0,5.803653910528
1994,18.0,8.242923128422401
1995,20.0,10.594338502737921
1996,30.0,14.475470802190337
1997,32.0,17.9803766

[Results for corrected sql]
2025-05-07 01:50:08 - Thread-28 (execute) - INFO - [Corrected other sqls]
```sql
--Description:  Corrected version of SQL #10 ─ Compute, for EVERY CPC group at
--              hierarchy LEVEL = 5, the calendar year in which its
--              exponential-moving-average (α = 0.2) of patent-filing counts
--              peaks.  Because Snowflake lacks a native EMA window function,
--              the EMA is implemented with a recursive CTE.
--              -------------------------------------------------------------
-- 1) first_cpc   – keep only the FIRST CPC code of each patent that has both
--                  a filing date and a non-empty application number.
-- 2) pub2grp     – map that CPC code to its ancestor CPC group at LEVEL = 5.
-- 3) yearly      – count filings per (group, year).
-- 4) ordered     – add a row number per group to enforce chronological order.
-- 5) ema_cte     – recursively compute EMA within each group:
--                     ema₁ = filings₁
--                     emaₜ = 0.2·filingsₜ + 0.8·emaₜ₋₁
-- 6) best_year   – per group, keep the year where EMA is maximal.
WITH first_cpc AS (                                                         -- 1
    SELECT  p."publication_number",
            p."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (
                PARTITION BY p."publication_number"
                ORDER BY     f.index
            ) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS p,
            LATERAL FLATTEN(input => p."cpc") f
    WHERE   p."application_number" IS NOT NULL
      AND   p."application_number" <> ''
      AND   p."filing_date" IS NOT NULL
),
pub2grp AS (                                                                -- 2
    SELECT  fc."publication_number",
            TO_NUMBER(SUBSTR(fc."filing_date"::STRING,1,4)) AS filing_year,
            c5."symbol"     AS "cpc_group_level5",
            c5."titleFull"  AS "cpc_title"
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc."cpc_code"
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
           ON POSITION(c5."symbol", fc."cpc_code") = 1
          AND c5."level" = 5
    WHERE   fc.rn = 1
),
yearly AS (                                                                  -- 3
    SELECT  "cpc_group_level5",
            "cpc_title",
            filing_year,
            COUNT(*)::FLOAT AS filings
    FROM    pub2grp
    GROUP BY 1,2,3
),
ordered AS (                                                                 -- 4
    SELECT  *,
            ROW_NUMBER() OVER (
                PARTITION BY "cpc_group_level5"
                ORDER BY     filing_year
            ) AS rn
    FROM    yearly
),
/* 5 ─ Recursive EMA -------------------------------------------------------- */
RECURSIVE ema_cte (cpc_group_level5, cpc_title, filing_year,
                   filings, ema_0_2, rn) AS (
    -- Anchor rows (first year of every group)
    SELECT  "cpc_group_level5",
            "cpc_title",
            filing_year,
            filings,
            filings AS ema_0_2,
            rn
    FROM    ordered
    WHERE   rn = 1
    UNION ALL
    -- Recursive step: ema_t = 0.2*value_t + 0.8*ema_{t-1}
    SELECT  o."cpc_group_level5",
            o."cpc_title",
            o.filing_year,
            o.filings,
            0.2 * o.filings + 0.8 * e.ema_0_2 AS ema_0_2,
            o.rn
    FROM    ema_cte e
    JOIN    ordered o
           ON o."cpc_group_level5" = e."cpc_group_level5"
          AND o.rn = e.rn + 1
),
best_year AS (                                                               -- 6
    SELECT  cpc_group_level5,
            cpc_title,
            filing_year AS best_year,
            ema_0_2     AS best_ema,
            ROW_NUMBER() OVER (
                PARTITION BY cpc_group_level5
                ORDER BY     ema_0_2 DESC
            ) AS rk
    FROM    ema_cte
)
SELECT  cpc_group_level5,
        cpc_title,
        best_year,
        best_ema
FROM    best_year
WHERE   rk = 1
ORDER BY best_ema DESC
LIMIT 20;
```
[Corrected other sqls]
2025-05-07 01:50:08 - Thread-28 (execute) - INFO - [Successfully corrected]
Successfully corrected. SQL:
--Description:  For the CPC subtree “H04L9/” (cryptographic aspects of digital
--              communication), compute yearly patent-filing counts and then an
--              exponential moving average (EMA) with smoothing factor α = 0.2.
--              Snowflake lacks a native EMA function, so we build it manually
--              using a recursive CTE:
--              • yearly   – counts per calendar year.
--              • ordered  – attach row numbers to force chronological order.
--              • ema_cte  – recursive EMA:  ema₁ = value₁ ;  emaₜ = 0.2·vₜ + 0.8·emaₜ₋₁.
--              The final result lists (year, filings, EMA) for the first
--              20 years in ascending order.
WITH RECURSIVE
/* 1 ─ Yearly filing counts ------------------------------------------------- */
yearly AS (
    SELECT  TO_NUMBER(SUBSTR(p."filing_date"::STRING, 1, 4)) AS filing_year,
            COUNT(*)::FLOAT                                   AS filings
    FROM    PATENTS.PATENTS.PUBLICATIONS       p,
            LATERAL FLATTEN(input => p."cpc")  f
    WHERE   f.value:"code"::STRING ILIKE 'H04L9/%'            -- target subtree
      AND   p."application_number" IS NOT NULL
      AND   p."application_number" <> ''
      AND   p."filing_date" IS NOT NULL
    GROUP BY 1
),
/* 2 ─ Impose chronological order ------------------------------------------ */
ordered AS (
    SELECT  filing_year,
            filings,
            ROW_NUMBER() OVER (ORDER BY filing_year) AS rn
    FROM    yearly
),
/* 3 ─ Recursive EMA calculation ------------------------------------------- */
ema_cte (filing_year, filings, ema_0_2, rn) AS (
    -- Anchor row (first year): EMA equals the first value
    SELECT  filing_year,
            filings,
            filings AS ema_0_2,
            rn
    FROM    ordered
    WHERE   rn = 1
    UNION ALL
    -- Recursive step: emaₜ = 0.2·valueₜ + 0.8·emaₜ₋₁
    SELECT  o.filing_year,
            o.filings,
            0.2 * o.filings + 0.8 * e.ema_0_2,
            o.rn
    FROM    ema_cte e
    JOIN    ordered o
           ON o.rn = e.rn + 1
)
/* ─────────────────────────────────────────────────────────────────────────── */
SELECT  filing_year,
        filings,
        ema_0_2
FROM    ema_cte
ORDER BY filing_year
LIMIT 20;
Results:
FILING_YEAR,FILINGS,EMA_0_2
1954,1.0,1.0
1967,6.0,2.0
1976,4.0,2.4000000000000004
1978,4.0,2.7200000000000006
1983,4.0,2.976000000000001
1984,1.0,2.580800000000001
1985,3.0,2.664640000000001
1986,3.0,2.731712000000001
1987,2.0,2.585369600000001
1989,4.0,2.868295680000001
1990,7.0,3.6946365440000006
1991,4.0,3.7557092352000003
1992,15.0,6.00456738816
1993,5.0,5.803653910528
1994,18.0,8.242923128422401
1995,20.0,10.594338502737921
1996,30.0,14.475470802190337
1997,32.0,17.9803766

[Successfully corrected]
2025-05-07 01:50:08 - Thread-28 (execute) - INFO - [Try to execute]
--Description:  Corrected version of SQL #10 ─ Compute, for EVERY CPC group at
--              hierarchy LEVEL = 5, the calendar year in which its
--              exponential-moving-average (α = 0.2) of patent-filing counts
--              peaks.  Because Snowflake lacks a native EMA window function,
--              the EMA is implemented with a recursive CTE.
--              -------------------------------------------------------------
-- 1) first_cpc   – keep only the FIRST CPC code of each patent that has both
--                  a filing date and a non-empty application number.
-- 2) pub2grp     – map that CPC code to its ancestor CPC group at LEVEL = 5.
-- 3) yearly      – count filings per (group, year).
-- 4) ordered     – add a row number per group to enforce chronological order.
-- 5) ema_cte     – recursively compute EMA within each group:
--                     ema₁ = filings₁
--                     emaₜ = 0.2·filingsₜ + 0.8·emaₜ₋₁
-- 6) best_year   – per group, keep the year where EMA is maximal.
WITH first_cpc AS (                                                         -- 1
    SELECT  p."publication_number",
            p."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (
                PARTITION BY p."publication_number"
                ORDER BY     f.index
            ) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS p,
            LATERAL FLATTEN(input => p."cpc") f
    WHERE   p."application_number" IS NOT NULL
      AND   p."application_number" <> ''
      AND   p."filing_date" IS NOT NULL
),
pub2grp AS (                                                                -- 2
    SELECT  fc."publication_number",
            TO_NUMBER(SUBSTR(fc."filing_date"::STRING,1,4)) AS filing_year,
            c5."symbol"     AS "cpc_group_level5",
            c5."titleFull"  AS "cpc_title"
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc."cpc_code"
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
           ON POSITION(c5."symbol", fc."cpc_code") = 1
          AND c5."level" = 5
    WHERE   fc.rn = 1
),
yearly AS (                                                                  -- 3
    SELECT  "cpc_group_level5",
            "cpc_title",
            filing_year,
            COUNT(*)::FLOAT AS filings
    FROM    pub2grp
    GROUP BY 1,2,3
),
ordered AS (                                                                 -- 4
    SELECT  *,
            ROW_NUMBER() OVER (
                PARTITION BY "cpc_group_level5"
                ORDER BY     filing_year
            ) AS rn
    FROM    yearly
),
/* 5 ─ Recursive EMA -------------------------------------------------------- */
RECURSIVE ema_cte (cpc_group_level5, cpc_title, filing_year,
                   filings, ema_0_2, rn) AS (
    -- Anchor rows (first year of every group)
    SELECT  "cpc_group_level5",
            "cpc_title",
            filing_year,
            filings,
            filings AS ema_0_2,
            rn
    FROM    ordered
    WHERE   rn = 1
    UNION ALL
    -- Recursive step: ema_t = 0.2*value_t + 0.8*ema_{t-1}
    SELECT  o."cpc_group_level5",
            o."cpc_title",
            o.filing_year,
            o.filings,
            0.2 * o.filings + 0.8 * e.ema_0_2 AS ema_0_2,
            o.rn
    FROM    ema_cte e
    JOIN    ordered o
           ON o."cpc_group_level5" = e."cpc_group_level5"
          AND o.rn = e.rn + 1
),
best_year AS (                                                               -- 6
    SELECT  cpc_group_level5,
            cpc_title,
            filing_year AS best_year,
            ema_0_2     AS best_ema,
            ROW_NUMBER() OVER (
                PARTITION BY cpc_group_level5
                ORDER BY     ema_0_2 DESC
            ) AS rk
    FROM    ema_cte
)
SELECT  cpc_group_level5,
        cpc_title,
        best_year,
        best_ema
FROM    best_year
WHERE   rk = 1
ORDER BY best_ema DESC
LIMIT 20
[Try to execute]
2025-05-07 01:50:08 - Thread-28 (execute) - INFO - [Error occurred]
{'status': 'error', 'error_msg': "##ERROR##001003 (42000): SQL compilation error:\nsyntax error line 45 at position 10 unexpected 'ema_cte'.\nsyntax error line 45 at position 19 unexpected 'cpc_group_level5'.\nsyntax error line 46 at position 41 unexpected 'AS'."}
[Error occurred]
2025-05-07 01:57:19 - Thread-28 (execute) - INFO - [Corrected SQL]
```sql
--Description:  Find, for every CPC technology area at hierarchy LEVEL = 5, the
--              calendar year in which its exponential-moving-average (EMA,
--              smoothing α = 0.2) of patent-filing counts is highest.
--              Snowflake lacks a native EMA window function, so the EMA is
--              computed in a recursive CTE.
--              Steps
--              1) first_cpc  – retain only the FIRST CPC code for each
--                 publication that has a filing date and non-empty application
--                 number.
--              2) pub2grp    – map that CPC to its ancestor CPC group whose
--                 definition row is at LEVEL 5.
--              3) yearly     – count filings per (group, year).
--              4) ordered    – add row numbers per group to impose year order.
--              5) ema_cte    – recursively calculate EMA within each group
--                     ema₁ = filings₁
--                     emaₜ = 0.2·filingsₜ + 0.8·emaₜ₋₁
--              6) best_year  – keep the year with the maximum EMA for each
--                 CPC group.
WITH RECURSIVE
/* 1 ─ first CPC code ------------------------------------------------------- */
first_cpc AS (
    SELECT  p."publication_number",
            p."filing_date",
            f.value:"code"::STRING                  AS "cpc_code",
            ROW_NUMBER() OVER (
                PARTITION BY p."publication_number"
                ORDER BY     f.index
            )                                       AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS p,
            LATERAL FLATTEN(input => p."cpc") f
    WHERE   p."application_number" IS NOT NULL
      AND   p."application_number" <> ''
      AND   p."filing_date" IS NOT NULL
),
/* 2 ─ map to level-5 CPC group -------------------------------------------- */
pub2grp AS (
    SELECT  fc."publication_number",
            TO_NUMBER(SUBSTR(fc."filing_date"::STRING,1,4)) AS filing_year,
            c5."symbol"     AS "cpc_group_level5",
            c5."titleFull"  AS "cpc_title"
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc."cpc_code"
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
           ON POSITION(c5."symbol", fc."cpc_code") = 1
          AND c5."level" = 5
    WHERE   fc.rn = 1
),
/* 3 ─ yearly filing counts ------------------------------------------------- */
yearly AS (
    SELECT  "cpc_group_level5",
            "cpc_title",
            filing_year,
            COUNT(*)::FLOAT AS filings
    FROM    pub2grp
    GROUP BY 1,2,3
),
/* 4 ─ impose chronological order ------------------------------------------ */
ordered AS (
    SELECT  *,
            ROW_NUMBER() OVER (
                PARTITION BY "cpc_group_level5"
                ORDER BY     filing_year
            ) AS rn
    FROM    yearly
),
/* 5 ─ recursive EMA per group --------------------------------------------- */
ema_cte (cpc_group_level5, cpc_title, filing_year,
         filings, ema_0_2, rn) AS (
    /* anchor (first year per group) */
    SELECT  "cpc_group_level5",
            "cpc_title",
            filing_year,
            filings,
            filings AS ema_0_2,
            rn
    FROM    ordered
    WHERE   rn = 1
    UNION ALL
    /* recursive step */
    SELECT  o."cpc_group_level5",
            o."cpc_title",
            o.filing_year,
            o.filings,
            0.2 * o.filings + 0.8 * e.ema_0_2,
            o.rn
    FROM    ema_cte e
    JOIN    ordered o
           ON o."cpc_group_level5" = e."cpc_group_level5"
          AND o.rn = e.rn + 1
),
/* 6 ─ choose best EMA year per group -------------------------------------- */
best_year AS (
    SELECT  cpc_group_level5,
            cpc_title,
            filing_year AS best_year,
            ema_0_2     AS best_ema,
            ROW_NUMBER() OVER (
                PARTITION BY cpc_group_level5
                ORDER BY     ema_0_2 DESC
            ) AS rk
    FROM    ema_cte
)
SELECT  cpc_group_level5,
        cpc_title,
        best_year,
        best_ema
FROM    best_year
WHERE   rk = 1
ORDER BY best_ema DESC
LIMIT 20;
```
[Corrected SQL]
2025-05-07 01:57:20 - Thread-28 (execute) - INFO - [Results for corrected sql]
{'status': 'error', 'error_msg': '##ERROR##000904 (42000): SQL compilation error: error line 71 at position 37\ninvalid identifier \'E."cpc_group_level5"\''}
[Results for corrected sql]
2025-05-07 02:05:59 - Thread-28 (execute) - INFO - [Corrected SQL]
```sql
--Description:  For every CPC technology area at hierarchy LEVEL = 5, find the
--              calendar year in which its exponential-moving-average (EMA,
--              α = 0.2) of patent-filing counts is highest.  Because Snowflake
--              has no built-in EMA function, the EMA is calculated with a
--              recursive CTE.
--              Workflow
--                1) first_cpc  – keep only the FIRST CPC code of each patent
--                   having a filing date and non-empty application number.
--                2) pub2grp    – map that CPC code to its ancestor CPC group
--                   whose definition row is at LEVEL 5.
--                3) yearly     – yearly filing counts per group.
--                4) ordered    – add a row number per group for chronology.
--                5) ema_cte    – recursively compute EMA:
--                       ema₁ = filings₁
--                       emaₜ = 0.2·filingsₜ + 0.8·emaₜ₋₁
--                6) best_year  – for each group, keep the year with the
--                   highest EMA.
WITH RECURSIVE
/* 1 ─ first CPC code ------------------------------------------------------- */
first_cpc AS (
    SELECT  p."publication_number",
            p."filing_date",
            f.value:"code"::STRING                AS cpc_code,
            ROW_NUMBER() OVER (
                PARTITION BY p."publication_number"
                ORDER BY     f.index
            )                                    AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS p,
            LATERAL FLATTEN(input => p."cpc") f
    WHERE   p."application_number" IS NOT NULL
      AND   p."application_number" <> ''
      AND   p."filing_date" IS NOT NULL
),
/* 2 ─ map to level-5 CPC group -------------------------------------------- */
pub2grp AS (
    SELECT  fc."publication_number",
            TO_NUMBER(SUBSTR(fc."filing_date"::STRING,1,4)) AS filing_year,
            c5."symbol"     AS cpc_group_level5,
            c5."titleFull"  AS cpc_title
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc.cpc_code
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
           ON POSITION(c5."symbol", fc.cpc_code) = 1
          AND c5."level" = 5
    WHERE   fc.rn = 1
),
/* 3 ─ yearly filing counts ------------------------------------------------- */
yearly AS (
    SELECT  cpc_group_level5,
            cpc_title,
            filing_year,
            COUNT(*)::FLOAT AS filings
    FROM    pub2grp
    GROUP BY 1,2,3
),
/* 4 ─ enforce chronological order ----------------------------------------- */
ordered AS (
    SELECT  *,
            ROW_NUMBER() OVER (
                PARTITION BY cpc_group_level5
                ORDER BY     filing_year
            ) AS rn
    FROM    yearly
),
/* 5 ─ recursive EMA per group --------------------------------------------- */
ema_cte (cpc_group_level5, cpc_title, filing_year,
         filings, ema_0_2, rn) AS (
    -- anchor (first year of each group)
    SELECT  cpc_group_level5,
            cpc_title,
            filing_year,
            filings,
            filings AS ema_0_2,
            rn
    FROM    ordered
    WHERE   rn = 1
    UNION ALL
    -- recursive step
    SELECT  o.cpc_group_level5,
            o.cpc_title,
            o.filing_year,
            o.filings,
            0.2 * o.filings + 0.8 * e.ema_0_2,
            o.rn
    FROM    ema_cte e
    JOIN    ordered o
           ON o.cpc_group_level5 = e.cpc_group_level5
          AND o.rn = e.rn + 1
),
/* 6 ─ select best EMA year per group -------------------------------------- */
best_year AS (
    SELECT  cpc_group_level5,
            cpc_title,
            filing_year AS best_year,
            ema_0_2     AS best_ema,
            ROW_NUMBER() OVER (
                PARTITION BY cpc_group_level5
                ORDER BY     ema_0_2 DESC
            ) AS rk
    FROM    ema_cte
)
SELECT  cpc_group_level5,
        cpc_title,
        best_year,
        best_ema
FROM    best_year
WHERE   rk = 1
ORDER BY best_ema DESC
LIMIT 20;
```
[Corrected SQL]
2025-05-07 02:06:48 - Thread-28 (execute) - INFO - [Results for corrected sql]
CPC_GROUP_LEVEL5,CPC_TITLE,BEST_YEAR,BEST_EMA
G06F,ELECTRIC DIGITAL DATA PROCESSING,2022,624.3713094257754
Y02E,"REDUCTION OF GREENHOUSE GAS [GHG] EMISSIONS, RELATED TO ENERGY GENERATION, TRANSMISSION OR DISTRIBUTION",2023,448.44419961579695
Y02P,CLIMATE CHANGE MITIGATION TECHNOLOGIES IN THE PRODUCTION OR PROCESSING OF GOODS,2023,393.3220924363192
H04L,"TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION",2021,322.4704621619459
H01L,SEMICONDUCTOR DEVICES NOT COVERED BY CLASS

[Results for corrected sql]
2025-05-07 02:06:48 - Thread-28 (execute) - INFO - [Successfully corrected]
Successfully corrected. SQL:
--Description:  For every CPC technology area at hierarchy LEVEL = 5, find the
--              calendar year in which its exponential-moving-average (EMA,
--              α = 0.2) of patent-filing counts is highest.  Because Snowflake
--              has no built-in EMA function, the EMA is calculated with a
--              recursive CTE.
--              Workflow
--                1) first_cpc  – keep only the FIRST CPC code of each patent
--                   having a filing date and non-empty application number.
--                2) pub2grp    – map that CPC code to its ancestor CPC group
--                   whose definition row is at LEVEL 5.
--                3) yearly     – yearly filing counts per group.
--                4) ordered    – add a row number per group for chronology.
--                5) ema_cte    – recursively compute EMA:
--                       ema₁ = filings₁
--                       emaₜ = 0.2·filingsₜ + 0.8·emaₜ₋₁
--                6) best_year  – for each group, keep the year with the
--                   highest EMA.
WITH RECURSIVE
/* 1 ─ first CPC code ------------------------------------------------------- */
first_cpc AS (
    SELECT  p."publication_number",
            p."filing_date",
            f.value:"code"::STRING                AS cpc_code,
            ROW_NUMBER() OVER (
                PARTITION BY p."publication_number"
                ORDER BY     f.index
            )                                    AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS p,
            LATERAL FLATTEN(input => p."cpc") f
    WHERE   p."application_number" IS NOT NULL
      AND   p."application_number" <> ''
      AND   p."filing_date" IS NOT NULL
),
/* 2 ─ map to level-5 CPC group -------------------------------------------- */
pub2grp AS (
    SELECT  fc."publication_number",
            TO_NUMBER(SUBSTR(fc."filing_date"::STRING,1,4)) AS filing_year,
            c5."symbol"     AS cpc_group_level5,
            c5."titleFull"  AS cpc_title
    FROM    first_cpc fc
    JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc.cpc_code
    JOIN    PATENTS.PATENTS.CPC_DEFINITION c5
           ON POSITION(c5."symbol", fc.cpc_code) = 1
          AND c5."level" = 5
    WHERE   fc.rn = 1
),
/* 3 ─ yearly filing counts ------------------------------------------------- */
yearly AS (
    SELECT  cpc_group_level5,
            cpc_title,
            filing_year,
            COUNT(*)::FLOAT AS filings
    FROM    pub2grp
    GROUP BY 1,2,3
),
/* 4 ─ enforce chronological order ----------------------------------------- */
ordered AS (
    SELECT  *,
            ROW_NUMBER() OVER (
                PARTITION BY cpc_group_level5
                ORDER BY     filing_year
            ) AS rn
    FROM    yearly
),
/* 5 ─ recursive EMA per group --------------------------------------------- */
ema_cte (cpc_group_level5, cpc_title, filing_year,
         filings, ema_0_2, rn) AS (
    -- anchor (first year of each group)
    SELECT  cpc_group_level5,
            cpc_title,
            filing_year,
            filings,
            filings AS ema_0_2,
            rn
    FROM    ordered
    WHERE   rn = 1
    UNION ALL
    -- recursive step
    SELECT  o.cpc_group_level5,
            o.cpc_title,
            o.filing_year,
            o.filings,
            0.2 * o.filings + 0.8 * e.ema_0_2,
            o.rn
    FROM    ema_cte e
    JOIN    ordered o
           ON o.cpc_group_level5 = e.cpc_group_level5
          AND o.rn = e.rn + 1
),
/* 6 ─ select best EMA year per group -------------------------------------- */
best_year AS (
    SELECT  cpc_group_level5,
            cpc_title,
            filing_year AS best_year,
            ema_0_2     AS best_ema,
            ROW_NUMBER() OVER (
                PARTITION BY cpc_group_level5
                ORDER BY     ema_0_2 DESC
            ) AS rk
    FROM    ema_cte
)
SELECT  cpc_group_level5,
        cpc_title,
        best_year,
        best_ema
FROM    best_year
WHERE   rk = 1
ORDER BY best_ema DESC
LIMIT 20;
Results:
CPC_GROUP_LEVEL5,CPC_TITLE,BEST_YEAR,BEST_EMA
G06F,ELECTRIC DIGITAL DATA PROCESSING,2022,624.3713094257754
Y02E,"REDUCTION OF GREENHOUSE GAS [GHG] EMISSIONS, RELATED TO ENERGY GENERATION, TRANSMISSION OR DISTRIBUTION",2023,448.44419961579695
Y02P,CLIMATE CHANGE MITIGATION TECHNOLOGIES IN THE PRODUCTION OR PROCESSING OF GOODS,2023,393.3220924363192
H04L,"TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION",2021,322.4704621619459
H01L,SEMICONDUCTOR DEVICES NOT COVERED BY CLASS

[Successfully corrected]
2025-05-07 02:06:48 - Thread-28 (execute) - INFO - itercount: 0
2025-05-07 02:06:48 - Thread-28 (execute) - INFO - [Self-refine]
Table full name: PATENTS.PATENTS.DISCLOSURES_13
Column name: serial_cleaned Type: TEXT
Column name: sso Type: TEXT
Column name: disclosure_event Type: TEXT
Column name: reciprocity Type: TEXT
Column name: patent_owner_harmonized Type: TEXT
Column name: record_id Type: TEXT
Column name: family_id Type: TEXT
Column name: blanket_scope Type: TEXT
Column name: copyright Type: TEXT
Column name: standard Type: TEXT
Column name: licensing_commitment Type: TEXT
Column name: committee_project Type: TEXT
Column name: sc_name Type: TEXT
Column name: blanket_type Type: TEXT
Column name: pub_cleaned Type: TEXT
Column name: third_party Type: TEXT
Column name: wg_name Type: TEXT
Column name: patent_owner_unharmonized Type: TEXT
Column name: tc_name Type: TEXT
Column name: date Type: NUMBER
Sample rows:
[{'family_id': '22549751', 'record_id': 'REC00002', 'disclosure_event': 'DE0001', 'sso': 'ANSI', 'patent_owner_harmonized': '3M', 'patent_owner_unharmonized': '3M', 'date': 19751124, 'standard': 'X3.55;X3.56', 'committee_project': '', 'tc_name': '', 'sc_name': '', 'wg_name': '', 'licensing_commitment': 'FRAND', 'copyright': '', 'blanket_type': '0', 'blanket_scope': '', 'third_party': '0', 'reciprocity': '0', 'serial_cleaned': '', 'pub_cleaned': 'US3692255'}, {'family_id': '23170520', 'record_id': 'REC00001', 'disclosure_event': 'DE0001', 'sso': 'ANSI', 'patent_owner_harmonized': '3M', 'patent_owner_unharmonized': '3M', 'date': 19751124, 'standard': 'X3.55;X3.56', 'committee_project': '', 'tc_name': '', 'sc_name': '', 'wg_name': '', 'licensing_commitment': 'FRAND', 'copyright': '', 'blanket_type': '0', 'blanket_scope': '', 'third_party': '0', 'reciprocity': '0', 'serial_cleaned': '', 'pub_cleaned': 'US3861619'}, {'family_id': '23170520', 'record_id': 'REC00006', 'disclosure_event': 'DE0003', 'sso': 'ANSI', 'patent_owner_harmonized': '3M', 'patent_owner_unharmonized': '3M', 'date': 19890711, 'standard': 'X3.55;X3.56;X3.72;X3.116;X3.127;X3.136', 'committee_project': '', 'tc_name': '', 'sc_name': '', 'wg_name': '', 'licensing_commitment': 'Specific Terms', 'copyright': '', 'blanket_type': '0', 'blanket_scope': '', 'third_party': '0', 'reciprocity': '0', 'serial_cleaned': '', 'pub_cleaned': 'US3861619'}, {'family_id': '22549751', 'record_id': 'REC00008', 'disclosure_event': 'DE0004', 'sso': 'ANSI', 'patent_owner_harmonized': '3M', 'patent_owner_unharmonized': '3M', 'date': 19890906, 'standard': '', 'committee_project': '', 'tc_name': '', 'sc_name': '', 'wg_name': '', 'licensing_commitment': 'FRAND', 'copyright': '', 'blanket_type': '2', 'blanket_scope': '', 'third_party': '0', 'reciprocity': '0', 'serial_cleaned': '', 'pub_cleaned': 'US3692255'}, {'family_id': '23418274', 'record_id': 'REC00024', 'disclosure_event': 'DE0013', 'sso': 'ANSI', 'patent_owner_harmonized': 'Agilent Technologies', 'patent_owner_unharmonized': 'Agilent Technologies', 'date': 20020606, 'standard': '1588', 'committee_project': 'IEEE', 'tc_name': '', 'sc_name': '', 'wg_name': '', 'licensing_commitment': 'FRAND', 'copyright': '', 'blanket_type': '0', 'blanket_scope': '', 'third_party': '0', 'reciprocity': '0', 'serial_cleaned': '', 'pub_cleaned': 'US5566180'}]

--------------------------------------------------
Table full name: PATENTS.PATENTS.PUBLICATIONS
Column name: examiner Type: VARIANT Description: Is this text truncated?
Column name: fterm Type: VARIANT Description: For US publications only, the description in HTML, limited to the first 9 megabytes
Column name: application_number_formatted Type: TEXT Description: Application number, formatted to the patent office format where possible.
Column name: application_number Type: TEXT Description: Patent application number (DOCDB compatible), eg: 'US-87124404-A'. This may not always be set.
Column name: grant_date Type: NUMBER Description: For US publications only, the claims in plain text
Column name: cpc Type: VARIANT Description: Two-letter language code for this text
Column name: locarno Type: VARIANT Description: Localized text
Column name: description_localized_html Type: VARIANT Description: Localized text
Column name: publication_date Type: NUMBER Description: Two-letter language code for this text
Column name: kind_code Type: TEXT Description: Kind code, indicating application, grant, search report, correction, etc. These are different for each country.
Column name: spif_publication_number Type: TEXT Description: SPIF standard (spif.group) publication number, after 2000
Column name: ipc Type: VARIANT Description: Localized text
Column name: pct_number Type: TEXT Description: PCT number for this application if it was part of a PCT filing, eg: 'PCT/EP2008/062623'.
Column name: entity_status Type: TEXT Description: The filing date.
Column name: filing_date Type: NUMBER Description: Is this text truncated?
Column name: abstract_localized Type: VARIANT Description: Localized text
Column name: description_localized Type: VARIANT Description: The publication abstracts in different languages
Column name: assignee Type: VARIANT Description: Localized text
Column name: citation Type: VARIANT Description: Two-letter language code for this text
Column name: fi Type: VARIANT Description: Is this text truncated?
Column name: claims_localized_html Type: VARIANT Description: Is this text truncated?
Column name: inventor_harmonized Type: VARIANT Description: For US publications only, the claims in HTML
Column name: inventor Type: VARIANT Description: Is this text truncated?
Column name: claims_localized Type: VARIANT Description: Two-letter language code for this text
Column name: priority_date Type: NUMBER Description: Localized text
Column name: application_kind Type: TEXT Description: High-level kind of the application: A=patent; U=utility; P=provision; W= PCT; F=design; T=translation.
Column name: priority_claim Type: VARIANT Description: Two-letter language code for this text
Column name: assignee_harmonized Type: VARIANT Description: Two-letter language code for this text
Column name: title_localized Type: VARIANT Description: The publication titles in different languages
Column name: art_unit Type: TEXT Description: The grant date, or 0 if not granted.
Column name: child Type: VARIANT Description: The publication date.
Column name: family_id Type: TEXT Description: Family ID (simple family). Grouping on family ID will return all publications associated with a simple patent family (all publications share the same priority claims).
Column name: spif_application_number Type: TEXT Description: SPIF standard (spif.group) application number, after 2000
Column name: uspc Type: VARIANT Description: For US publications only, the description in plain text, limited to the first 9 megabytes
Column name: publication_number Type: TEXT Description: Patent publication number (DOCDB compatible), eg: 'US-7650331-B1'
Column name: country_code Type: TEXT Description: Country code, eg: 'US', 'EP', etc
Column name: parent Type: VARIANT Description: Is this text truncated?
Sample rows:
[{'publication_number': 'DE-69611147-T2', 'application_number': 'DE-69611147-T', 'country_code': 'DE', 'kind_code': 'T2', 'application_kind': 'T', 'application_number_formatted': 'DE1996611147', 'pct_number': '', 'family_id': '9483724', 'spif_publication_number': '', 'spif_application_number': '', 'title_localized': '[\n  {\n    "language": "de",\n    "text": "Schloss vom Typ eines entkuppelbaren Rotors",\n    "truncated": false\n  }\n]', 'abstract_localized': '[]', 'claims_localized': '[]', 'claims_localized_html': '[]', 'description_localized': '[]', 'description_localized_html': '[]', 'publication_date': 20010621, 'filing_date': 19961015, 'grant_date': 20010621, 'priority_date': 19951018, 'priority_claim': '[\n  {\n    "application_number": "FR-9512326-A",\n    "category": "",\n    "filing_date": 19951018,\n    "npl_text": "",\n    "publication_number": "",\n    "type": ""\n  }\n]', 'inventor': '[\n  "MENAGER, CHRISTOPHE",\n  "CANARD, LOUIS",\n  "CADOUOT, PATRICK",\n  "GOURDIN, DOMINIQUE"\n]', 'inventor_harmonized': '[\n  {\n    "country_code": "FR",\n    "name": "MENAGER CHRISTOPHE"\n  },\n  {\n    "country_code": "FR",\n    "name": "CANARD LOUIS"\n  },\n  {\n    "country_code": "FR",\n    "name": "CADOUOT PATRICK"\n  },\n  {\n    "country_code": "FR",\n    "name": "GOURDIN DOMINIQUE"\n  }\n]', 'assignee': '[\n  "Valeo Securite Habitacle, Creteil Cedex"\n]', 'assignee_harmonized': '[\n  {\n    "country_code": "FR",\n    "name": "VALEO SECURITE HABITACLE"\n  }\n]', 'examiner': '[]', 'uspc': '[]', 'ipc': '[\n  {\n    "code": "E05B17/04",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "E05B17/00",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  }\n]', 'cpc': '[\n  {\n    "code": "E05B77/00",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "E05B17/0058",\n    "first": true,\n    "inventive": true,\n    "tree": []\n  }\n]', 'fi': '[]', 'fterm': '[]', 'locarno': '[]', 'citation': '[]', 'parent': '[]', 'child': '[]', 'entity_status': '', 'art_unit': ''}, {'publication_number': 'DE-69630331-T2', 'application_number': 'DE-69630331-T', 'country_code': 'DE', 'kind_code': 'T2', 'application_kind': 'T', 'application_number_formatted': 'DE1996630331', 'pct_number': '', 'family_id': '23689246', 'spif_publication_number': '', 'spif_application_number': '', 'title_localized': '[\n  {\n    "language": "de",\n    "text": "Verfahren zur gesicherten Sitzungsschlüsselerzeugung und zur Authentifizierung",\n    "truncated": false\n  }\n]', 'abstract_localized': '[]', 'claims_localized': '[]', 'claims_localized_html': '[]', 'description_localized': '[]', 'description_localized_html': '[]', 'publication_date': 20040729, 'filing_date': 19960416, 'grant_date': 20040729, 'priority_date': 19950421, 'priority_claim': '[\n  {\n    "application_number": "US-42609095-A",\n    "category": "",\n    "filing_date": 19950421,\n    "npl_text": "",\n    "publication_number": "",\n    "type": ""\n  }\n]', 'inventor': '[\n  "VANSTONE SCOTT .A, WATERLOO",\n  "MENEZES ALFRED JOHN, AUBURN",\n  "MINGHUA QU,"\n]', 'inventor_harmonized': '[\n  {\n    "country_code": "CA",\n    "name": "VANSTONE SCOTT A WATERLOO"\n  },\n  {\n    "country_code": "US",\n    "name": "MENEZES ALFRED JOHN AUBURN"\n  },\n  {\n    "country_code": "CA",\n    "name": "MINGHUA QU"\n  }\n]', 'assignee': '[\n  "Certicom Corp., Mississauga"\n]', 'assignee_harmonized': '[\n  {\n    "country_code": "CA",\n    "name": "CERTICOM CORP"\n  }\n]', 'examiner': '[]', 'uspc': '[]', 'ipc': '[\n  {\n    "code": "H04L9/08",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "G06F7/72",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  }\n]', 'cpc': '[\n  {\n    "code": "G06F7/725",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "H04L9/0844",\n    "first": true,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "H04L9/0838",\n    "first": true,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "H04L9/0844",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "G06F7/725",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  }\n]', 'fi': '[]', 'fterm': '[]', 'locarno': '[]', 'citation': '[]', 'parent': '[]', 'child': '[]', 'entity_status': '', 'art_unit': ''}, {'publication_number': 'DE-69636755-T2', 'application_number': 'DE-69636755-T', 'country_code': 'DE', 'kind_code': 'T2', 'application_kind': 'T', 'application_number_formatted': 'DE1996636755', 'pct_number': '', 'family_id': '8224764', 'spif_publication_number': '', 'spif_application_number': '', 'title_localized': '[\n  {\n    "language": "de",\n    "text": "Immortalisierte menschliche Epithelzell-Linie",\n    "truncated": false\n  }\n]', 'abstract_localized': '[\n  {\n    "language": "en",\n    "text": "Immortalised human corneal epithelial cell line, comprises cells of the cell line which are capable of stratification and expressing metabolic markers specific for nonimmortalised human epithelial cells, differentiation markers specific for nonimmortalised human corneal epithelial cells and markers specific for an inflammatory reaction.",\n    "truncated": false\n  }\n]', 'claims_localized': '[]', 'claims_localized_html': '[]', 'description_localized': '[]', 'description_localized_html': '[]', 'publication_date': 20071011, 'filing_date': 19961224, 'grant_date': 20071011, 'priority_date': 19961224, 'priority_claim': '[\n  {\n    "application_number": "EP-96203707-A",\n    "category": "",\n    "filing_date": 19961224,\n    "npl_text": "",\n    "publication_number": "",\n    "type": ""\n  }\n]', 'inventor': '[\n  "OFFORD CAVIN, ELIZABETH",\n  "TROMVOUKIS, YVONNE",\n  "PFEIFER, ANDREA M.A.",\n  "SHARIF, NAJ"\n]', 'inventor_harmonized': '[\n  {\n    "country_code": "CH",\n    "name": "OFFORD CAVIN ELIZABETH"\n  },\n  {\n    "country_code": "CH",\n    "name": "TROMVOUKIS YVONNE"\n  },\n  {\n    "country_code": "CH",\n    "name": "PFEIFER ANDREA M A"\n  },\n  {\n    "country_code": "US",\n    "name": "SHARIF NAJ"\n  }\n]', 'assignee': '[\n  "Société des Produits Nestlé S.A."\n]', 'assignee_harmonized': '[\n  {\n    "country_code": "CH",\n    "name": "NESTLE SA"\n  }\n]', 'examiner': '[]', 'uspc': '[]', 'ipc': '[\n  {\n    "code": "C12N5/10",\n    "first": true,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "G01N33/50",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "C12R1/91",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "C12N15/09",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "C12N5/00",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "A61K35/44",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "G01N33/48",\n    "first": true,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "C12Q1/68",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "C12N5/071",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  }\n]', 'cpc': '[\n  {\n    "code": "C12N2503/02",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "C12N5/0621",\n    "first": true,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "C12N2503/02",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "C12N2510/04",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "C12N5/0621",\n    "first": true,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "C12N2510/04",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  }\n]', 'fi': '[]', 'fterm': '[]', 'locarno': '[]', 'citation': '[]', 'parent': '[]', 'child': '[]', 'entity_status': '', 'art_unit': ''}, {'publication_number': 'DE-69728658-T2', 'application_number': 'DE-69728658-T', 'country_code': 'DE', 'kind_code': 'T2', 'application_kind': 'T', 'application_number_formatted': 'DE1997628658', 'pct_number': '', 'family_id': '24437397', 'spif_publication_number': '', 'spif_application_number': '', 'title_localized': '[\n  {\n    "language": "de",\n    "text": "Lithographische dünne filmstruktur und diese enthaltende druckplatte",\n    "truncated": false\n  }\n]', 'abstract_localized': '[\n  {\n    "language": "en",\n    "text": "A lithographic laser imageable thin film structure comprising a substrate having first and second surfaces. A vacuum-deposited metal layer is carried by the first surface of the substrate. A layer of semiconductor material is adhered to and overlies the metal layer. The metal layer and the semiconductor material have thicknesses which are selected to maximize absorption of laser energy impinging on the same.",\n    "truncated": false\n  }\n]', 'claims_localized': '[]', 'claims_localized_html': '[]', 'description_localized': '[]', 'description_localized_html': '[]', 'publication_date': 20040812, 'filing_date': 19970115, 'grant_date': 20040812, 'priority_date': 19960229, 'priority_claim': '[\n  {\n    "application_number": "US-9700408-W",\n    "category": "",\n    "filing_date": 19970115,\n    "npl_text": "",\n    "publication_number": "",\n    "type": ""\n  },\n  {\n    "application_number": "US-60864696-A",\n    "category": "",\n    "filing_date": 19960229,\n    "npl_text": "",\n    "publication_number": "",\n    "type": ""\n  }\n]', 'inventor': '[\n  "FISHER, P.",\n  "PHILLIPS, W.",\n  "DAVIS, F.",\n  "LEGALLEE, CHARLOTTE"\n]', 'inventor_harmonized': '[\n  {\n    "country_code": "US",\n    "name": "FISHER P"\n  },\n  {\n    "country_code": "US",\n    "name": "PHILLIPS W"\n  },\n  {\n    "country_code": "US",\n    "name": "DAVIS F"\n  },\n  {\n    "country_code": "US",\n    "name": "LEGALLEE CHARLOTTE"\n  }\n]', 'assignee': '[\n  "Presstek, Inc."\n]', 'assignee_harmonized': '[\n  {\n    "country_code": "US",\n    "name": "PRESSTEK INC"\n  }\n]', 'examiner': '[]', 'uspc': '[]', 'ipc': '[\n  {\n    "code": "B32B15/04",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "B41C1/10",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "B41N1/00",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "B41N1/14",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "B32B27/20",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "B32B7/02",\n    "first": true,\n    "inventive": true,\n    "tree": []\n  }\n]', 'cpc': '[\n  {\n    "code": "B32B15/04",\n    "first": true,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "Y10T428/12674",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "B32B27/20",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "Y10T428/31678",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "Y10T428/12458",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "Y10T428/31678",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "Y10T428/12458",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "B32B15/20",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "Y10T428/31504",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "B41N1/00",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "B32B15/09",\n    "first": true,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "B32B2367/00",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "B32B27/20",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "Y10T428/12493",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "B32B15/043",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "B32B27/36",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "B32B27/08",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "B32B15/04",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "Y10T428/12493",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "Y10T428/12674",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "B41C1/1033",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "B41N1/00",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "Y10T428/12528",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "Y10T428/31504",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "B41C1/1033",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "B32B2311/24",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "Y10T428/12528",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  }\n]', 'fi': '[]', 'fterm': '[]', 'locarno': '[]', 'citation': '[]', 'parent': '[]', 'child': '[]', 'entity_status': '', 'art_unit': ''}, {'publication_number': 'DE-69807539-T2', 'application_number': 'DE-69807539-T', 'country_code': 'DE', 'kind_code': 'T2', 'application_kind': 'T', 'application_number_formatted': 'DE1998607539', 'pct_number': '', 'family_id': '11877005', 'spif_publication_number': '', 'spif_application_number': '', 'title_localized': '[\n  {\n    "language": "de",\n    "text": "Automatisches Analysegerät",\n    "truncated": false\n  }\n]', 'abstract_localized': '[]', 'claims_localized': '[]', 'claims_localized_html': '[]', 'description_localized': '[]', 'description_localized_html': '[]', 'publication_date': 20030116, 'filing_date': 19980120, 'grant_date': 20030116, 'priority_date': 19970129, 'priority_claim': '[\n  {\n    "application_number": "JP-1501397-A",\n    "category": "",\n    "filing_date": 19970129,\n    "npl_text": "",\n    "publication_number": "",\n    "type": ""\n  }\n]', 'inventor': '[\n  "HANAWA, MASAAKI",\n  "MITSUMAKI, HIROSHI",\n  "OHISHI, TADASHI",\n  "KAI, SUSUMU",\n  "WATANABE, HIROSHI"\n]', 'inventor_harmonized': '[\n  {\n    "country_code": "JP",\n    "name": "HANAWA MASAAKI"\n  },\n  {\n    "country_code": "JP",\n    "name": "MITSUMAKI HIROSHI"\n  },\n  {\n    "country_code": "JP",\n    "name": "OHISHI TADASHI"\n  },\n  {\n    "country_code": "JP",\n    "name": "KAI SUSUMU"\n  },\n  {\n    "country_code": "JP",\n    "name": "WATANABE HIROSHI"\n  }\n]', 'assignee': '[\n  "Hitachi, Ltd."\n]', 'assignee_harmonized': '[\n  {\n    "country_code": "JP",\n    "name": "HITACHI LTD"\n  }\n]', 'examiner': '[]', 'uspc': '[]', 'ipc': '[\n  {\n    "code": "G01N35/00",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "G01N35/02",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "G01N35/04",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  }\n]', 'cpc': '[\n  {\n    "code": "Y10T436/115831",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "Y10T436/114165",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "G01N2035/0465",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "G01N35/026",\n    "first": true,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "G01N2035/0467",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "Y10T436/113332",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "Y10T436/114165",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "G01N35/00603",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "Y10T436/11",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "G01N2035/00326",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "G01N2035/0467",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "G01N35/00603",\n    "first": false,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "G01N2035/00326",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "G01N2035/0465",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "G01N35/026",\n    "first": true,\n    "inventive": true,\n    "tree": []\n  },\n  {\n    "code": "Y10T436/11",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "Y10T436/113332",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  },\n  {\n    "code": "Y10T436/115831",\n    "first": false,\n    "inventive": false,\n    "tree": []\n  }\n]', 'fi': '[]', 'fterm': '[]', 'locarno': '[]', 'citation': '[]', 'parent': '[]', 'child': '[]', 'entity_status': '', 'art_unit': ''}]

--------------------------------------------------
Table full name: PATENTS.PATENTS.CPC_DEFINITION
Column name: status Type: TEXT
Column name: precedenceLimitingReferences Type: VARIANT
Column name: rules Type: VARIANT
Column name: childGroups Type: VARIANT
Column name: scopeLimitingReferences Type: VARIANT
Column name: level Type: FLOAT
Column name: titlePart Type: VARIANT
Column name: residualReferences Type: VARIANT
Column name: definition Type: VARIANT
Column name: breakdownCode Type: BOOLEAN
Column name: limitingReferences Type: VARIANT
Column name: glossary Type: VARIANT
Column name: applicationReferences Type: VARIANT
Column name: notAllocatable Type: BOOLEAN
Column name: titleFull Type: TEXT
Column name: dateRevised Type: FLOAT
Column name: informativeReferences Type: VARIANT
Column name: symbol Type: TEXT
Column name: synonyms Type: VARIANT
Column name: children Type: VARIANT
Column name: parents Type: VARIANT
Column name: ipcConcordant Type: TEXT
Sample rows:
[{'applicationReferences': '[]', 'breakdownCode': True, 'childGroups': '[]', 'children': '[]', 'dateRevised': 20130101.0, 'definition': '[]', 'glossary': '[]', 'informativeReferences': '[]', 'ipcConcordant': 'CPCONLY', 'level': 9.0, 'limitingReferences': '[]', 'notAllocatable': False, 'parents': '[\n  "A01K2227/10",\n  "A01K2227/00",\n  "A01K",\n  "A01",\n  "A"\n]', 'precedenceLimitingReferences': '[]', 'residualReferences': '[]', 'rules': '[]', 'scopeLimitingReferences': '[]', 'status': 'published', 'symbol': 'A01K2227/108', 'synonyms': '[]', 'titleFull': 'Swine', 'titlePart': '[\n  "Swine"\n]'}, {'applicationReferences': '[]', 'breakdownCode': True, 'childGroups': '[]', 'children': '[]', 'dateRevised': 20130101.0, 'definition': '[]', 'glossary': '[]', 'informativeReferences': '[]', 'ipcConcordant': 'CPCONLY', 'level': 9.0, 'limitingReferences': '[]', 'notAllocatable': False, 'parents': '[\n  "A01K2227/10",\n  "A01K2227/00",\n  "A01K",\n  "A01",\n  "A"\n]', 'precedenceLimitingReferences': '[]', 'residualReferences': '[]', 'rules': '[]', 'scopeLimitingReferences': '[]', 'status': 'published', 'symbol': 'A01K2227/105', 'synonyms': '[]', 'titleFull': 'Murine', 'titlePart': '[\n  "Murine"\n]'}, {'applicationReferences': '[]', 'breakdownCode': True, 'childGroups': '[]', 'children': '[]', 'dateRevised': 20130101.0, 'definition': '[]', 'glossary': '[]', 'informativeReferences': '[]', 'ipcConcordant': 'CPCONLY', 'level': 9.0, 'limitingReferences': '[]', 'notAllocatable': False, 'parents': '[\n  "A01K2227/10",\n  "A01K2227/00",\n  "A01K",\n  "A01",\n  "A"\n]', 'precedenceLimitingReferences': '[]', 'residualReferences': '[]', 'rules': '[]', 'scopeLimitingReferences': '[]', 'status': 'published', 'symbol': 'A01K2227/107', 'synonyms': '[]', 'titleFull': 'Rabbit', 'titlePart': '[\n  "Rabbit"\n]'}, {'applicationReferences': '[]', 'breakdownCode': True, 'childGroups': '[]', 'children': '[]', 'dateRevised': 20130101.0, 'definition': '[]', 'glossary': '[]', 'informativeReferences': '[]', 'ipcConcordant': 'CPCONLY', 'level': 9.0, 'limitingReferences': '[]', 'notAllocatable': False, 'parents': '[\n  "A01K2267/02",\n  "A01K2267/00",\n  "A01K",\n  "A01",\n  "A"\n]', 'precedenceLimitingReferences': '[]', 'residualReferences': '[]', 'rules': '[]', 'scopeLimitingReferences': '[]', 'status': 'published', 'symbol': 'A01K2267/025', 'synonyms': '[]', 'titleFull': 'Animal producing cells or organs for transplantation', 'titlePart': '[\n  "Animal producing cells or organs for transplantation"\n]'}, {'applicationReferences': '[]', 'breakdownCode': True, 'childGroups': '[]', 'children': '[\n  "A01K2267/0312",\n  "A01K2267/0318",\n  "A01K2267/0325"\n]', 'dateRevised': 20130101.0, 'definition': '[]', 'glossary': '[]', 'informativeReferences': '[]', 'ipcConcordant': 'CPCONLY', 'level': 9.0, 'limitingReferences': '[]', 'notAllocatable': False, 'parents': '[\n  "A01K2267/03",\n  "A01K2267/00",\n  "A01K",\n  "A01",\n  "A"\n]', 'precedenceLimitingReferences': '[]', 'residualReferences': '[]', 'rules': '[]', 'scopeLimitingReferences': '[]', 'status': 'published', 'symbol': 'A01K2267/0306', 'synonyms': '[]', 'titleFull': 'Animal model for genetic diseases', 'titlePart': '[\n  "Animal model for genetic diseases"\n]'}]

--------------------------------------------------
External knowledge that might be helpful: 
None
The table structure information is ({database name: {schema name: [table name]}}): 
{'PATENTS': {'PATENTS': ['DISCLOSURES_13', 'PUBLICATIONS', 'CPC_DEFINITION']}}

Some few-shot examples after column exploration may be helpful:
Query:
--Description: 1) Peek at a few CPC-entries (as JSON) together with publication & filing dates
SELECT  t."publication_number",
        t."application_number",
        t."filing_date",
        t."cpc"
FROM    PATENTS.PATENTS.PUBLICATIONS t
WHERE   t."cpc" IS NOT NULL
LIMIT 20;
Answer:
publication_number,application_number,filing_date,cpc
CN-2384262-Y,CN-99220041-U,19990304,[]
CN-2368443-Y,CN-99223233-U,19990325,[]
CN-2375662-Y,CN-99231678-U,19990524,[]
CN-2385653-Y,CN-99236750-U,19990727,[]
CN-2382415-Y,CN-99238338-U,19990817,[]
CN-2405417-Y,CN-99258085-U,19991228,[]
ES-1070067-Y,ES-200900212-U,20090209,[]
GR-2001887-Y,GR-960200239-U,19961003,[]
CN-2649912-Y,CN-200320103967-U,20031103,[]
CN-2663940-Y,CN-200320104650-U,20031226,[]
CN-2669819-Y,CN-200320107671-U,2003
Query:
--Description: 2) Flatten the CPC array and show the first 20 raw CPC codes
SELECT  t."publication_number",
        f.value:"code"::STRING AS "cpc_code"
FROM    PATENTS.PATENTS.PUBLICATIONS t,
        LATERAL FLATTEN(input => t."cpc") f
LIMIT 20;
Answer:
publication_number,cpc_code
HK-6083-A,H02M5/00
HU-T52763-A,A01N47/36
HU-T52763-A,C07D521/00
JP-H03206829-A,Y02A40/81
JP-S62159089-A,Y02E30/30
US-416-A,Y10T83/465
US-416-A,B26F1/42
US-2528225-A,E21B27/02
US-2528225-A,E21B27/02
AT-A41580-A,B22D11/086
AT-A47682-A,C07D471/16
AT-A47682-A,C07D471/22
AT-A63682-A,G01N33/48728
CA-920790-A,C03C4/12
CA-920790-A,C03C4/12
CA-950907-A,C11B5/0064
CA-950907-A,C08K5/35
CA-950907-A,C11B5/0035
Query:
--Description: 3) Distinct CPC codes that really occur in the data together with their total occurrence count
SELECT  f.value:"code"::STRING AS "cpc_code",
        COUNT(*) AS "n_publications"
FROM    PATENTS.PATENTS.PUBLICATIONS t,
        LATERAL FLATTEN(input => t."cpc") f
GROUP BY 1
ORDER BY 2 DESC
LIMIT 20;
Answer:
cpc_code,n_publications
Y02E60/10,5576
A61P35/00,5514
A61P43/00,3803
A61K45/06,3065
Y02P70/50,2621
A61P29/00,2555
A61K38/00,2489
A61P25/00,2136
A61K2039/505,1915
Y02T10/12,1834
Y02E10/50,1825
A23V2002/00,1817
Y02T10/70,1777
C07D471/04,1747
H01L2924/0002,1714
A61P25/28,1694
Y02E60/50,1668
Y02A50/30,1659
H01M10/0525,1650
Y02D30/70,1618
Query:
--Description: 4) Same flattening, but keep only patents with a non-empty application number and a valid filing date
SELECT  t."publication_number",
        t."application_number",
        t."filing_date",
        f.value:"code"::STRING AS "cpc_code"
FROM    PATENTS.PATENTS.PUBLICATIONS t,
        LATERAL FLATTEN(input => t."cpc") f
WHERE   t."application_number" IS NOT NULL
  AND   t."application_number" <> ''
  AND   t."filing_date"          IS NOT NULL
LIMIT 20;
Answer:
publication_number,application_number,filing_date,cpc_code
WO-2017120317-A1,US-2017012308-W,20170105,B01L3/502753
WO-2017120317-A1,US-2017012308-W,20170105,B01L2300/0864
WO-2017120317-A1,US-2017012308-W,20170105,B01L2200/0647
WO-2017120317-A1,US-2017012308-W,20170105,G01N33/491
WO-2017120317-A1,US-2017012308-W,20170105,B01L2300/0864
WO-2017120317-A1,US-2017012308-W,20170105,B01L2300/0627
WO-2017120317-A1,US-2017012308-W,20170105,B01L3/502746
WO-2017120317-A1,US-2017012308-W,20170105,G01N
Query:
--Description: 5) Look at the CPC definition table: sample rows with level, symbol and full title
SELECT  d."symbol",
        d."level",
        d."titleFull"
FROM    PATENTS.PATENTS.CPC_DEFINITION d
LIMIT 20;
Answer:
symbol,level,titleFull
B,2.0,PERFORMING OPERATIONS; TRANSPORTING
H,2.0,ELECTRICITY
Y,2.0,GENERAL TAGGING OF NEW TECHNOLOGICAL DEVELOPMENTS; GENERAL TAGGING OF CROSS-SECTIONAL TECHNOLOGIES SPANNING OVER SEVERAL SECTIONS OF THE IPC; TECHNICAL SUBJECTS COVERED BY FORMER USPC CROSS-REFERENCE ART COLLECTIONS [XRACs] AND DIGESTS
D,2.0,TEXTILES; PAPER
F,2.0,MECHANICAL ENGINEERING; LIGHTING; HEATING; WEAPONS; BLASTING
E,2.0,FIXED CONSTRUCTIONS
C,2.0,CHEMISTRY; METALLURGY
G,2.0,PHYSICS
Query:
--Description: 6) Fetch a few CPC groups at hierarchy level 5 together with their titles
SELECT  d."symbol"  AS "cpc_group_level5",
        d."titleFull"
FROM    PATENTS.PATENTS.CPC_DEFINITION d
WHERE   d."level" = 5
LIMIT 20;
Answer:
cpc_group_level5,titleFull
A01H,NEW PLANTS OR NON-TRANSGENIC PROCESSES FOR OBTAINING THEM; PLANT REPRODUCTION BY TISSUE CULTURE TECHNIQUES
A01F,PROCESSING OF HARVESTED PRODUCE; HAY OR STRAW PRESSES; DEVICES FOR STORING AGRICULTURAL OR HORTICULTURAL PRODUCE
A01C,PLANTING; SOWING; FERTILISING
A01G,"HORTICULTURE; CULTIVATION OF VEGETABLES, FLOWERS, RICE, FRUIT, VINES, HOPS OR SEAWEED; FORESTRY; WATERING"
A01N,"PRESERVATION OF BODIES OF HUMANS OR ANIMALS OR PLANTS OR PARTS THEREOF; BIOCIDES, e.
Query:
--Description: 7) Join first CPC code of each publication to its level-5 group & show one sample row per publication
WITH first_cpc AS (
    SELECT  t."publication_number",
            t."filing_date",
            f.value:"code"::STRING AS "cpc_code",
            ROW_NUMBER() OVER (PARTITION BY t."publication_number" ORDER BY f.index) AS rn
    FROM    PATENTS.PATENTS.PUBLICATIONS t,
            LATERAL FLATTEN(input => t."cpc") f
    WHERE   t."application_number" IS NOT NULL
      AND   t."application_number" <> ''
      AND   t."filing_date" IS NOT NULL
)
SELECT  fc."publication_number",
        fc."filing_date",
        c5."symbol"        AS "cpc_group_level5",
        c5."titleFull"
FROM    first_cpc fc
JOIN    PATENTS.PATENTS.CPC_DEFINITION cdef
           ON cdef."symbol" = fc."cpc_code"
JOIN    PATENTS.PATENTS.CPC_DEFINITION c5        -- walk up to level-5 ancestor
           ON POSITION(c5."symbol", fc."cpc_code") = 1
          AND c5."level" = 5
WHERE   fc.rn = 1
LIMIT 20;
Answer:
publication_number,filing_date,cpc_group_level5,titleFull
CN-115143231-A,20220727,F16F,SPRINGS; SHOCK-ABSORBERS; MEANS FOR DAMPING VIBRATION
JP-2013247671-A,20121226,H01L,SEMICONDUCTOR DEVICES NOT COVERED BY CLASS H10
US-8862771-B2,20081220,H04L,"TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION"
JP-2020006907-A,20180712,F16F,SPRINGS; SHOCK-ABSORBERS; MEANS FOR DAMPING VIBRATION
AT-E226854-T1,19950505,G01N,INVESTIGATING OR ANALYSING MATERIALS BY DETERMINING THEIR CHEMICAL 
Task: Identify the CPC technology areas with the highest exponential moving average of patent filings each year (with a smoothing factor of 0.2), considering only the first CPC code for each patent that has a valid filing date and a non-empty application number, and report the full CPC title along with the best year associated with the highest exponential moving average for each CPC group at level 5.

Please think step by step and answer only one complete SQL in snowflake dialect in ```sql``` format.
SQL usage example: ```sql
SELECT "COLUMN_NAME" FROM DATABASE.SCHEMA.TABLE WHERE ... ``` (Adjust "DATABASE", "SCHEMA", and "TABLE" to match actual names, ensure all column names are enclosed in double quotations)
Here are some useful tips for answering:
When performing a UNION operation on many tables, ensure that all table names are explicitly listed. Union first and then add condition and selection. e.g. SELECT "col1", "col2" FROM (TABLE1 UNION ALL TABLE2) WHERE ...; Don't write sqls as (SELECT col1, col2 FROM TABLE1 WHERE ...) UNION ALL (SELECT col1, col2 FROM TABLE2 WHERE ...); Don't use ['-- Include all', '-- Omit', '-- Continue', '-- Union all', '-- ...', '-- List all', '-- Replace this', '-- Each table', '-- Add other'] to omit any table. Table names here: The table structure information is ({database name: {schema name: [table name]}}): 
{'PATENTS': {'PATENTS': ['DISCLOSURES_13', 'PUBLICATIONS', 'CPC_DEFINITION']}}

When using ORDER BY xxx DESC, add NULLS LAST to exclude null records: ORDER BY xxx DESC NULLS LAST.
If the task description does not specify the number of decimal places, retain all decimals to four places.

[Self-refine]
2025-05-07 02:13:26 - Thread-28 (execute) - INFO - [Try to run SQL in self-refine]
```sql
/* 1) get the first CPC code for every publication having a filing year      */
WITH first_cpc AS (
    SELECT
        p."publication_number",
        FLOOR(p."filing_date"/10000)                       AS filing_year,   -- YYYY from YYYYMMDD
        f.value:"code"::STRING                            AS cpc_code,
        ROW_NUMBER() OVER (PARTITION BY p."publication_number" ORDER BY f.index) AS rn
    FROM PATENTS.PATENTS.PUBLICATIONS  p,
         LATERAL FLATTEN (input => p."cpc")               f
    WHERE p."application_number" IS NOT NULL
      AND TRIM(p."application_number") <> ''
      AND p."filing_date"           IS NOT NULL
),
first_cpc_only AS (
    SELECT * 
    FROM   first_cpc
    WHERE  rn = 1                                   -- keep only first CPC code
),

/* 2) map every CPC code to its level-5 CPC technology group                 */
cpc_level5 AS (
    SELECT
        fc.filing_year,
        d5."symbol"      AS cpc_group,              -- level-5 CPC group (e.g. H04L)
        d5."titleFull"   AS cpc_title
    FROM   first_cpc_only                         fc
    JOIN   PATENTS.PATENTS.CPC_DEFINITION        d5
           ON  d5."level" = 5
           AND REGEXP_LIKE(fc.cpc_code , '^' || d5."symbol")   -- prefix match
),

/* 3) yearly filing counts per CPC level-5 group                             */
yearly_counts AS (
    SELECT
        cpc_group,
        cpc_title,
        filing_year   AS year,
        COUNT(*)      AS n_filings
    FROM   cpc_level5
    GROUP  BY cpc_group, cpc_title, filing_year
),

/* 4) rank the years inside every group to prepare for the recursive EMA     */
ranked_years AS (
    SELECT
        cpc_group,
        cpc_title,
        year,
        n_filings,
        ROW_NUMBER() OVER (PARTITION BY cpc_group ORDER BY year) AS rn
    FROM   yearly_counts
),

/* 5) recursive computation of the exponential moving average (α = 0.2)      */
RECURSIVE ema_cte AS (
    /* base year (earliest) ------------------------------------------------- */
    SELECT
        cpc_group,
        cpc_title,
        year,
        n_filings,
        rn,
        n_filings::FLOAT                         AS ema               -- EMA₁ = count₁
    FROM   ranked_years
    WHERE  rn = 1
    UNION ALL
    /* subsequent years ----------------------------------------------------- */
    SELECT
        r.cpc_group,
        r.cpc_title,
        r.year,
        r.n_filings,
        r.rn,
        0.2 * r.n_filings + 0.8 * e.ema         AS ema               -- EMAₜ = α·xₜ + (1-α)·EMAₜ₋₁
    FROM   ema_cte        e
    JOIN   ranked_years   r
           ON  r.cpc_group = e.cpc_group
           AND r.rn       = e.rn + 1
),

/* 6) pick the year with the highest EMA for every CPC group                 */
best_year AS (
    SELECT
        cpc_group,
        cpc_title,
        year          AS best_year,
        ema           AS highest_ema,
        ROW_NUMBER() OVER (PARTITION BY cpc_group ORDER BY ema DESC, year) AS rn
    FROM   ema_cte
)

/* 7) final result ---------------------------------------------------------- */
SELECT
    cpc_group          AS "cpc_group_level5",
    cpc_title          AS "cpc_title_full",
    best_year          AS "best_year",
    ROUND(highest_ema, 4) AS "highest_ema"
FROM   best_year
WHERE  rn = 1
ORDER  BY highest_ema DESC NULLS LAST;
```
[Try to run SQL in self-refine]
2025-05-07 02:13:28 - Thread-28 (execute) - INFO - itercount: 1
2025-05-07 02:13:28 - Thread-28 (execute) - INFO - [Self-refine]
Input sql:
/* 1) get the first CPC code for every publication having a filing year      */
WITH first_cpc AS (
    SELECT
        p."publication_number",
        FLOOR(p."filing_date"/10000)                       AS filing_year,   -- YYYY from YYYYMMDD
        f.value:"code"::STRING                            AS cpc_code,
        ROW_NUMBER() OVER (PARTITION BY p."publication_number" ORDER BY f.index) AS rn
    FROM PATENTS.PATENTS.PUBLICATIONS  p,
         LATERAL FLATTEN (input => p."cpc")               f
    WHERE p."application_number" IS NOT NULL
      AND TRIM(p."application_number") <> ''
      AND p."filing_date"           IS NOT NULL
),
first_cpc_only AS (
    SELECT * 
    FROM   first_cpc
    WHERE  rn = 1                                   -- keep only first CPC code
),

/* 2) map every CPC code to its level-5 CPC technology group                 */
cpc_level5 AS (
    SELECT
        fc.filing_year,
        d5."symbol"      AS cpc_group,              -- level-5 CPC group (e.g. H04L)
        d5."titleFull"   AS cpc_title
    FROM   first_cpc_only                         fc
    JOIN   PATENTS.PATENTS.CPC_DEFINITION        d5
           ON  d5."level" = 5
           AND REGEXP_LIKE(fc.cpc_code , '^' || d5."symbol")   -- prefix match
),

/* 3) yearly filing counts per CPC level-5 group                             */
yearly_counts AS (
    SELECT
        cpc_group,
        cpc_title,
        filing_year   AS year,
        COUNT(*)      AS n_filings
    FROM   cpc_level5
    GROUP  BY cpc_group, cpc_title, filing_year
),

/* 4) rank the years inside every group to prepare for the recursive EMA     */
ranked_years AS (
    SELECT
        cpc_group,
        cpc_title,
        year,
        n_filings,
        ROW_NUMBER() OVER (PARTITION BY cpc_group ORDER BY year) AS rn
    FROM   yearly_counts
),

/* 5) recursive computation of the exponential moving average (α = 0.2)      */
RECURSIVE ema_cte AS (
    /* base year (earliest) ------------------------------------------------- */
    SELECT
        cpc_group,
        cpc_title,
        year,
        n_filings,
        rn,
        n_filings::FLOAT                         AS ema               -- EMA₁ = count₁
    FROM   ranked_years
    WHERE  rn = 1
    UNION ALL
    /* subsequent years ----------------------------------------------------- */
    SELECT
        r.cpc_group,
        r.cpc_title,
        r.year,
        r.n_filings,
        r.rn,
        0.2 * r.n_filings + 0.8 * e.ema         AS ema               -- EMAₜ = α·xₜ + (1-α)·EMAₜ₋₁
    FROM   ema_cte        e
    JOIN   ranked_years   r
           ON  r.cpc_group = e.cpc_group
           AND r.rn       = e.rn + 1
),

/* 6) pick the year with the highest EMA for every CPC group                 */
best_year AS (
    SELECT
        cpc_group,
        cpc_title,
        year          AS best_year,
        ema           AS highest_ema,
        ROW_NUMBER() OVER (PARTITION BY cpc_group ORDER BY ema DESC, year) AS rn
    FROM   ema_cte
)

/* 7) final result ---------------------------------------------------------- */
SELECT
    cpc_group          AS "cpc_group_level5",
    cpc_title          AS "cpc_title_full",
    best_year          AS "best_year",
    ROUND(highest_ema, 4) AS "highest_ema"
FROM   best_year
WHERE  rn = 1
ORDER  BY highest_ema DESC NULLS LAST;
The error information is:
{'status': 'error', 'error_msg': "##ERROR##001003 (42000): SQL compilation error:\nsyntax error line 54 at position 10 unexpected 'ema_cte'."}
Please correct it and output only 1 complete SQL query.
[Self-refine]
2025-05-07 02:14:40 - Thread-28 (execute) - INFO - [Try to run SQL in self-refine]
```sql
/* ---------------------------------------------------------------
   CPC level-5 groups with the highest EMA (α = 0.2) of yearly
   patent filings, using only the first CPC code per publication
-----------------------------------------------------------------*/
WITH RECURSIVE

/* 1) first CPC code for publications that have a filing date
      and a non-empty application number                            */
first_cpc AS (
    SELECT
        p."publication_number",
        FLOOR(p."filing_date" / 10000)                 AS filing_year,   -- extract YYYY
        f.value:"code"::STRING                        AS cpc_code,
        ROW_NUMBER() OVER (PARTITION BY p."publication_number"
                           ORDER BY f.index)          AS rn
    FROM PATENTS.PATENTS.PUBLICATIONS  p,
         LATERAL FLATTEN (input => p."cpc") f
    WHERE p."application_number" IS NOT NULL
      AND TRIM(p."application_number") <> ''
      AND p."filing_date" IS NOT NULL
),

first_cpc_only AS (
    SELECT * 
    FROM   first_cpc
    WHERE  rn = 1                     -- keep only the first CPC code
),

/* 2) map CPC codes to their level-5 ancestor                        */
cpc_level5 AS (
    SELECT
        fc.filing_year,
        d5."symbol"    AS cpc_group,      -- e.g. H04L
        d5."titleFull" AS cpc_title
    FROM   first_cpc_only                  fc
    JOIN   PATENTS.PATENTS.CPC_DEFINITION  d5
           ON d5."level" = 5
          AND REGEXP_LIKE(fc.cpc_code , CONCAT('^', d5."symbol"))  -- prefix match
),

/* 3) yearly counts per CPC level-5                                   */
yearly_counts AS (
    SELECT
        cpc_group,
        cpc_title,
        filing_year   AS "year",
        COUNT(*)      AS n_filings
    FROM   cpc_level5
    GROUP BY cpc_group, cpc_title, filing_year
),

/* 4) rank each year inside every group (oldest first)                */
ranked_years AS (
    SELECT
        cpc_group,
        cpc_title,
        "year",
        n_filings,
        ROW_NUMBER() OVER (PARTITION BY cpc_group ORDER BY "year") AS rn
    FROM   yearly_counts
),

/* 5) recursive EMA calculation (α = 0.2)                             */
ema_cte AS (
    /* seed row: first year of each group                              */
    SELECT
        cpc_group,
        cpc_title,
        "year",
        n_filings,
        rn,
        n_filings::FLOAT                     AS ema            -- EMA₁ = x₁
    FROM   ranked_years
    WHERE  rn = 1

    UNION ALL

    /* recursive part: remaining years                                 */
    SELECT
        r.cpc_group,
        r.cpc_title,
        r."year",
        r.n_filings,
        r.rn,
        0.2 * r.n_filings + 0.8 * e.ema      AS ema            -- EMAₜ = α·xₜ + (1-α)·EMAₜ₋₁
    FROM   ema_cte      e
    JOIN   ranked_years r
           ON  r.cpc_group = e.cpc_group
          AND r.rn        = e.rn + 1
),

/* 6) select best (highest EMA) year for each CPC group               */
best_year AS (
    SELECT
        cpc_group,
        cpc_title,
        "year"                 AS best_year,
        ema                    AS highest_ema,
        ROW_NUMBER() OVER (PARTITION BY cpc_group
                           ORDER BY ema DESC, "year") AS rn
    FROM   ema_cte
)

/* 7) final result                                                    */
SELECT
    cpc_group          AS "cpc_group_level5",
    cpc_title          AS "cpc_title_full",
    best_year          AS "best_year",
    ROUND(highest_ema, 4) AS "highest_ema"
FROM   best_year
WHERE  rn = 1
ORDER  BY highest_ema DESC NULLS LAST;
```
[Try to run SQL in self-refine]
2025-05-07 02:14:43 - Thread-28 (execute) - INFO - itercount: 2
2025-05-07 02:14:43 - Thread-28 (execute) - INFO - [Self-refine]
Input sql:
/* ---------------------------------------------------------------
   CPC level-5 groups with the highest EMA (α = 0.2) of yearly
   patent filings, using only the first CPC code per publication
-----------------------------------------------------------------*/
WITH RECURSIVE

/* 1) first CPC code for publications that have a filing date
      and a non-empty application number                            */
first_cpc AS (
    SELECT
        p."publication_number",
        FLOOR(p."filing_date" / 10000)                 AS filing_year,   -- extract YYYY
        f.value:"code"::STRING                        AS cpc_code,
        ROW_NUMBER() OVER (PARTITION BY p."publication_number"
                           ORDER BY f.index)          AS rn
    FROM PATENTS.PATENTS.PUBLICATIONS  p,
         LATERAL FLATTEN (input => p."cpc") f
    WHERE p."application_number" IS NOT NULL
      AND TRIM(p."application_number") <> ''
      AND p."filing_date" IS NOT NULL
),

first_cpc_only AS (
    SELECT * 
    FROM   first_cpc
    WHERE  rn = 1                     -- keep only the first CPC code
),

/* 2) map CPC codes to their level-5 ancestor                        */
cpc_level5 AS (
    SELECT
        fc.filing_year,
        d5."symbol"    AS cpc_group,      -- e.g. H04L
        d5."titleFull" AS cpc_title
    FROM   first_cpc_only                  fc
    JOIN   PATENTS.PATENTS.CPC_DEFINITION  d5
           ON d5."level" = 5
          AND REGEXP_LIKE(fc.cpc_code , CONCAT('^', d5."symbol"))  -- prefix match
),

/* 3) yearly counts per CPC level-5                                   */
yearly_counts AS (
    SELECT
        cpc_group,
        cpc_title,
        filing_year   AS "year",
        COUNT(*)      AS n_filings
    FROM   cpc_level5
    GROUP BY cpc_group, cpc_title, filing_year
),

/* 4) rank each year inside every group (oldest first)                */
ranked_years AS (
    SELECT
        cpc_group,
        cpc_title,
        "year",
        n_filings,
        ROW_NUMBER() OVER (PARTITION BY cpc_group ORDER BY "year") AS rn
    FROM   yearly_counts
),

/* 5) recursive EMA calculation (α = 0.2)                             */
ema_cte AS (
    /* seed row: first year of each group                              */
    SELECT
        cpc_group,
        cpc_title,
        "year",
        n_filings,
        rn,
        n_filings::FLOAT                     AS ema            -- EMA₁ = x₁
    FROM   ranked_years
    WHERE  rn = 1

    UNION ALL

    /* recursive part: remaining years                                 */
    SELECT
        r.cpc_group,
        r.cpc_title,
        r."year",
        r.n_filings,
        r.rn,
        0.2 * r.n_filings + 0.8 * e.ema      AS ema            -- EMAₜ = α·xₜ + (1-α)·EMAₜ₋₁
    FROM   ema_cte      e
    JOIN   ranked_years r
           ON  r.cpc_group = e.cpc_group
          AND r.rn        = e.rn + 1
),

/* 6) select best (highest EMA) year for each CPC group               */
best_year AS (
    SELECT
        cpc_group,
        cpc_title,
        "year"                 AS best_year,
        ema                    AS highest_ema,
        ROW_NUMBER() OVER (PARTITION BY cpc_group
                           ORDER BY ema DESC, "year") AS rn
    FROM   ema_cte
)

/* 7) final result                                                    */
SELECT
    cpc_group          AS "cpc_group_level5",
    cpc_title          AS "cpc_title_full",
    best_year          AS "best_year",
    ROUND(highest_ema, 4) AS "highest_ema"
FROM   best_year
WHERE  rn = 1
ORDER  BY highest_ema DESC NULLS LAST;
The error information is:
No data found for the specified query.

Please correct it and output only 1 complete SQL query.
[Self-refine]
2025-05-07 02:17:34 - Thread-28 (execute) - INFO - [Try to run SQL in self-refine]
```sql
/* -------------------------------------------------------------------------
   CPC level-5 groups with the highest exponential moving average (α = 0.2)
   of yearly patent filings.  Only the first CPC code per publication that
   has a valid filing date and non-empty application number is considered.
---------------------------------------------------------------------------*/
WITH RECURSIVE

/* 1) First CPC code for each publication ----------------------------------*/
first_cpc AS (
    SELECT
        p."publication_number",
        FLOOR(p."filing_date" / 10000)                       AS filing_year,   -- YYYY
        f.value:"code"::STRING                               AS cpc_code,
        ROW_NUMBER() OVER (PARTITION BY p."publication_number"
                           ORDER BY f.index)                 AS rn
    FROM PATENTS.PATENTS.PUBLICATIONS  AS p,
         LATERAL FLATTEN(input => p."cpc") AS f
    WHERE p."application_number" IS NOT NULL
      AND TRIM(p."application_number") <> ''
      AND p."filing_date" IS NOT NULL
),

first_cpc_only AS (          -- keep only the very first CPC code
    SELECT *
    FROM   first_cpc
    WHERE  rn = 1
),

/* 2) Map each CPC code to its level-5 CPC group ---------------------------*/
cpc_level5 AS (
    SELECT
        fc.filing_year,
        d5."symbol"      AS cpc_group,        -- e.g. H04L
        d5."titleFull"   AS cpc_title
    FROM   first_cpc_only                  AS fc
    JOIN   PATENTS.PATENTS.CPC_DEFINITION  AS d5
           ON  d5."level" = 5
           AND POSITION(d5."symbol", fc.cpc_code) = 1   -- prefix match
),

/* 3) Yearly filing counts per CPC group -----------------------------------*/
yearly_counts AS (
    SELECT
        cpc_group,
        cpc_title,
        filing_year                          AS year,
        COUNT(*)                             AS n_filings
    FROM   cpc_level5
    GROUP  BY cpc_group, cpc_title, filing_year
),

/* 4) Rank the years chronologically for each group ------------------------*/
ranked_years AS (
    SELECT
        cpc_group,
        cpc_title,
        year,
        n_filings,
        ROW_NUMBER() OVER (PARTITION BY cpc_group ORDER BY year) AS rn
    FROM   yearly_counts
),

/* 5) Recursive EMA calculation (α = 0.2) ----------------------------------*/
ema_cte AS (
    /* seed: first year of each group */
    SELECT
        cpc_group,
        cpc_title,
        year,
        n_filings,
        rn,
        n_filings::FLOAT                         AS ema                 -- EMA₁ = x₁
    FROM   ranked_years
    WHERE  rn = 1

    UNION ALL

    /* recursive step: remaining years */
    SELECT
        r.cpc_group,
        r.cpc_title,
        r.year,
        r.n_filings,
        r.rn,
        0.2 * r.n_filings + 0.8 * e.ema          AS ema                 -- EMAₜ
    FROM   ema_cte        AS e
    JOIN   ranked_years   AS r
           ON r.cpc_group = e.cpc_group
          AND r.rn        = e.rn + 1
),

/* 6) Pick the best (highest EMA) year per CPC group -----------------------*/
best_year AS (
    SELECT
        cpc_group,
        cpc_title,
        year                 AS best_year,
        ema                  AS highest_ema,
        ROW_NUMBER() OVER (PARTITION BY cpc_group
                           ORDER BY ema DESC, year) AS rn
    FROM   ema_cte
)

/* 7) Final result ---------------------------------------------------------*/
SELECT
    cpc_group            AS "cpc_group_level5",
    cpc_title            AS "cpc_title_full",
    best_year            AS "best_year",
    ROUND(highest_ema,4) AS "highest_ema"
FROM best_year
WHERE rn = 1
ORDER BY highest_ema DESC NULLS LAST;
```
[Try to run SQL in self-refine]
2025-05-07 02:19:05 - Thread-28 (execute) - INFO - Total iteration counts: 2
