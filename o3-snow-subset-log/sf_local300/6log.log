2025-05-07 07:05:14 - Thread-615 (execute) - INFO - [Exploration]
```sql
-- 1) Preview a few raw customer transactions
--    (shows date, amount and type for quick context)
SELECT 
  "customer_id",
  "txn_date",
  "txn_amount",
  "txn_type"
FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
LIMIT 20;
```

```sql
-- 2) List the different transaction types that exist
SELECT DISTINCT 
  "txn_type"
FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
LIMIT 20;
```

```sql
-- 3) For every customer, see their earliest and latest transaction dates
--    together with total amount that moved on record
WITH cte AS (
  SELECT
    "customer_id",
    MIN("txn_date") AS "min_txn_date",
    MAX("txn_date") AS "max_txn_date",
    SUM(CASE WHEN "txn_type" ILIKE 'deposit' 
             THEN "txn_amount" 
             ELSE -1 * "txn_amount" END) AS "net_amount"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
  GROUP BY "customer_id"
)
SELECT * FROM cte
LIMIT 20;
```

```sql
-- 4) Compute a running balance per-customer per-day **only on the days a
--    transaction happened** (positive = deposit, negative = withdrawal)
WITH txns AS (
  SELECT
    "customer_id",
    TO_DATE("txn_date") AS "txn_date",
    CASE WHEN "txn_type" ILIKE 'deposit' 
         THEN "txn_amount" 
         ELSE -1 * "txn_amount" END           AS "signed_amount"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (
  SELECT
    "customer_id",
    "txn_date",
    SUM("signed_amount") 
      OVER (PARTITION BY "customer_id"
            ORDER BY "txn_date"
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
  FROM txns
)
SELECT * FROM running
LIMIT 20;
```

```sql
-- 5) Expand every customer’s activity window into **all calendar days**
--    between their first & last transaction dates
WITH bounds AS (
  SELECT
    "customer_id",
    MIN(TO_DATE("txn_date")) AS "start_dt",
    MAX(TO_DATE("txn_date")) AS "end_dt"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
  GROUP BY "customer_id"
), calendar AS (
  SELECT
    b."customer_id",
    DATEADD(day, seq4(), b."start_dt") AS "calendar_dt"
  FROM bounds b,
       TABLE(GENERATOR(ROWCOUNT => 3650))          -- sufficient length
  WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
)
SELECT * FROM calendar
LIMIT 20;
```

```sql
-- 6) Bring in the running balances (from Query-4) onto the full calendar,
--    then carry the previous balance forward to fill missing-day gaps
WITH txns AS (
  SELECT
    "customer_id",
    TO_DATE("txn_date") AS "txn_date",
    CASE WHEN "txn_type" ILIKE 'deposit' 
         THEN "txn_amount" 
         ELSE -1 * "txn_amount" END AS "signed_amount"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), daily_running AS (
  SELECT
    "customer_id",
    "txn_date",
    SUM("signed_amount")
      OVER (PARTITION BY "customer_id"
            ORDER BY "txn_date"
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
  FROM txns
), bounds AS (
  SELECT
    "customer_id",
    MIN("txn_date") AS "start_dt",
    MAX("txn_date") AS "end_dt"
  FROM daily_running
  GROUP BY "customer_id"
), calendar AS (
  SELECT
    b."customer_id",
    DATEADD(day, seq4(), b."start_dt") AS "calendar_dt"
  FROM bounds b,
       TABLE(GENERATOR(ROWCOUNT => 3650))
  WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (
  SELECT
    c."customer_id",
    c."calendar_dt",
    d."running_balance"
  FROM calendar c
  LEFT JOIN daily_running d
        ON c."customer_id" = d."customer_id"
       AND c."calendar_dt" = d."txn_date"
), filled AS (
  SELECT
    "customer_id",
    "calendar_dt",
    COALESCE(
      LAST_VALUE("running_balance") 
        IGNORE NULLS
        OVER (PARTITION BY "customer_id" 
              ORDER BY "calendar_dt"),
      0
    ) AS "daily_balance"
  FROM joined
)
SELECT * FROM filled
LIMIT 20;
```

```sql
-- 7) Replace any negative daily balances with zero (per requirement)
WITH filled AS (  /* replicate Query-6 logic until daily balances step */ 
  SELECT
    j."customer_id",
    j."calendar_dt",
    COALESCE(
      LAST_VALUE(j."running_balance") 
        IGNORE NULLS
        OVER (PARTITION BY j."customer_id" 
              ORDER BY j."calendar_dt"),
      0
    ) AS "daily_balance"
  FROM (
        /* calendar-plus-running logic abbreviated for brevity */
        SELECT
          c."customer_id",
          c."calendar_dt",
          d."running_balance"
        FROM (
              /* calendar build */
              SELECT
                b."customer_id",
                DATEADD(day, seq4(), b."start_dt") AS "calendar_dt"
              FROM (
                    SELECT
                      "customer_id",
                      MIN(TO_DATE("txn_date")) AS "start_dt",
                      MAX(TO_DATE("txn_date")) AS "end_dt"
                    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
                    GROUP BY "customer_id"
              ) b,
              TABLE(GENERATOR(ROWCOUNT => 3650))
              WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
          ) c
          LEFT JOIN (
              /* running balance */
              SELECT
                "customer_id",
                TO_DATE("txn_date") AS "txn_date",
                SUM(CASE WHEN "txn_type" ILIKE 'deposit' 
                         THEN "txn_amount" 
                         ELSE -1 * "txn_amount" END)
                  OVER (PARTITION BY "customer_id"
                        ORDER BY TO_DATE("txn_date")
                        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
              FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
          ) d
          ON c."customer_id" = d."customer_id" 
         AND c."calendar_dt" = d."txn_date"
    ) j
), clipped AS (
  SELECT
    "customer_id",
    "calendar_dt",
    CASE WHEN "daily_balance" < 0 THEN 0 ELSE "daily_balance" END AS "daily_balance"
  FROM filled
)
SELECT * FROM clipped
LIMIT 20;
```

```sql
-- 8) For each customer & month, find the highest daily balance in that month
WITH clipped AS ( /* use the result logic from Query-7 */ 
  SELECT
    "customer_id",
    "calendar_dt",
    CASE WHEN "daily_balance" < 0 THEN 0 ELSE "daily_balance" END AS "daily_balance"
  FROM ( /* placeholder for full daily construct */ )
), month_max AS (
  SELECT
    "customer_id",
    TO_CHAR("calendar_dt", 'YYYY-MM') AS "month_id",
    MAX("daily_balance") AS "max_daily_balance"
  FROM clipped
  GROUP BY "customer_id", TO_CHAR("calendar_dt", 'YYYY-MM')
)
SELECT * FROM month_max
LIMIT 20;
```

```sql
-- 9) Aggregate across customers – monthly total of their peak balances
WITH month_max AS ( /* reuse Query-8 logic */ 
  SELECT
    "customer_id",
    TO_CHAR("calendar_dt", 'YYYY-MM') AS "month_id",
    MAX("daily_balance") AS "max_daily_balance"
  FROM ( /* full daily balances from Query-7-clipped */ )
  GROUP BY "customer_id", TO_CHAR("calendar_dt", 'YYYY-MM')
)
SELECT
  "month_id",
  SUM("max_daily_balance") AS "total_peak_balance"
FROM month_max
GROUP BY "month_id"
LIMIT 20;
```

```sql
-- 10) (Optional drill-down) See which customers contributed most to a
--     given month’s peak-balance pool (example: January-2020)
WITH month_max AS ( /* pull from Query-8 */ 
  SELECT
    "customer_id",
    TO_CHAR("calendar_dt", 'YYYY-MM') AS "month_id",
    MAX("daily_balance") AS "max_daily_balance"
  FROM ( /* full daily balances from Query-7-clipped */ )
  GROUP BY "customer_id", TO_CHAR("calendar_dt", 'YYYY-MM')
)
SELECT
  "customer_id",
  "max_daily_balance"
FROM month_max
WHERE "month_id" = '2020-01'
ORDER BY "max_daily_balance" DESC
LIMIT 20;
```
[Exploration]
2025-05-07 07:05:14 - Thread-615 (execute) - INFO - [Try to execute]
-- 1) Preview a few raw customer transactions
--    (shows date, amount and type for quick context)
SELECT 
  "customer_id",
  "txn_date",
  "txn_amount",
  "txn_type"
FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
LIMIT 20;
[Try to execute]
2025-05-07 07:05:15 - Thread-615 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
-- 1) Preview a few raw customer transactions
--    (shows date, amount and type for quick context)
SELECT 
  "customer_id",
  "txn_date",
  "txn_amount",
  "txn_type"
FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
LIMIT 20;
Results:
customer_id,txn_date,txn_amount,txn_type
429,2020-01-21,82,deposit
155,2020-01-10,712,deposit
398,2020-01-01,196,deposit
255,2020-01-14,563,deposit
185,2020-01-29,626,deposit
309,2020-01-13,995,deposit
312,2020-01-20,485,deposit
376,2020-01-03,706,deposit
188,2020-01-13,601,deposit
138,2020-01-11,520,deposit
373,2020-01-18,596,deposit
361,2020-01-12,797,deposit
169,2020-01-10,628,deposit
402,2020-01-05,435,deposit
60,2020-01-19,495,deposit

[Successfully executed]
2025-05-07 07:05:15 - Thread-615 (execute) - INFO - [Try to execute]
-- 2) List the different transaction types that exist
SELECT DISTINCT 
  "txn_type"
FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
LIMIT 20;
[Try to execute]
2025-05-07 07:05:16 - Thread-615 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
-- 2) List the different transaction types that exist
SELECT DISTINCT 
  "txn_type"
FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
LIMIT 20;
Results:
txn_type
deposit
withdrawal
purchase

[Successfully executed]
2025-05-07 07:05:16 - Thread-615 (execute) - INFO - [Try to execute]
-- 3) For every customer, see their earliest and latest transaction dates
--    together with total amount that moved on record
WITH cte AS (
  SELECT
    "customer_id",
    MIN("txn_date") AS "min_txn_date",
    MAX("txn_date") AS "max_txn_date",
    SUM(CASE WHEN "txn_type" ILIKE 'deposit' 
             THEN "txn_amount" 
             ELSE -1 * "txn_amount" END) AS "net_amount"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
  GROUP BY "customer_id"
)
SELECT * FROM cte
LIMIT 20;
[Try to execute]
2025-05-07 07:05:16 - Thread-615 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
-- 3) For every customer, see their earliest and latest transaction dates
--    together with total amount that moved on record
WITH cte AS (
  SELECT
    "customer_id",
    MIN("txn_date") AS "min_txn_date",
    MAX("txn_date") AS "max_txn_date",
    SUM(CASE WHEN "txn_type" ILIKE 'deposit' 
             THEN "txn_amount" 
             ELSE -1 * "txn_amount" END) AS "net_amount"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
  GROUP BY "customer_id"
)
SELECT * FROM cte
LIMIT 20;
Results:
customer_id,min_txn_date,max_txn_date,net_amount
309,2020-01-13,2020-04-09,-960
205,2020-01-02,2020-03-15,1067
287,2020-01-22,2020-04-11,-406
412,2020-01-01,2020-02-19,608
257,2020-01-20,2020-04-13,-976
378,2020-01-07,2020-03-21,1590
63,2020-01-06,2020-03-31,-3946
1,2020-01-02,2020-03-19,-640
46,2020-01-23,2020-04-20,104
406,2020-01-26,2020-04-10,2279
142,2020-01-16,2020-04-01,863
236,2020-01-27,2020-04-14,-100
162,2020-01-10,2020-02-08,784
172,2020-01-12,2020-03-16,-1038

[Successfully executed]
2025-05-07 07:05:16 - Thread-615 (execute) - INFO - [Try to execute]
-- 4) Compute a running balance per-customer per-day **only on the days a
--    transaction happened** (positive = deposit, negative = withdrawal)
WITH txns AS (
  SELECT
    "customer_id",
    TO_DATE("txn_date") AS "txn_date",
    CASE WHEN "txn_type" ILIKE 'deposit' 
         THEN "txn_amount" 
         ELSE -1 * "txn_amount" END           AS "signed_amount"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (
  SELECT
    "customer_id",
    "txn_date",
    SUM("signed_amount") 
      OVER (PARTITION BY "customer_id"
            ORDER BY "txn_date"
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
  FROM txns
)
SELECT * FROM running
LIMIT 20;
[Try to execute]
2025-05-07 07:05:16 - Thread-615 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
-- 4) Compute a running balance per-customer per-day **only on the days a
--    transaction happened** (positive = deposit, negative = withdrawal)
WITH txns AS (
  SELECT
    "customer_id",
    TO_DATE("txn_date") AS "txn_date",
    CASE WHEN "txn_type" ILIKE 'deposit' 
         THEN "txn_amount" 
         ELSE -1 * "txn_amount" END           AS "signed_amount"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (
  SELECT
    "customer_id",
    "txn_date",
    SUM("signed_amount") 
      OVER (PARTITION BY "customer_id"
            ORDER BY "txn_date"
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
  FROM txns
)
SELECT * FROM running
LIMIT 20;
Results:
customer_id,txn_date,running_balance
324,2020-01-04,538
324,2020-01-04,1021
324,2020-01-28,203
324,2020-02-09,967
324,2020-03-22,1152
324,2020-03-29,2139
324,2020-03-29,1470
468,2020-01-25,939
468,2020-01-29,39
468,2020-02-14,-863
468,2020-02-19,-155
468,2020-03-02,-115
468,2020-03-02,-141
468,2020-03-18,-917

[Successfully executed]
2025-05-07 07:05:16 - Thread-615 (execute) - INFO - [Try to execute]
-- 5) Expand every customer’s activity window into **all calendar days**
--    between their first & last transaction dates
WITH bounds AS (
  SELECT
    "customer_id",
    MIN(TO_DATE("txn_date")) AS "start_dt",
    MAX(TO_DATE("txn_date")) AS "end_dt"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
  GROUP BY "customer_id"
), calendar AS (
  SELECT
    b."customer_id",
    DATEADD(day, seq4(), b."start_dt") AS "calendar_dt"
  FROM bounds b,
       TABLE(GENERATOR(ROWCOUNT => 3650))          -- sufficient length
  WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
)
SELECT * FROM calendar
LIMIT 20;
[Try to execute]
2025-05-07 07:05:17 - Thread-615 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
-- 5) Expand every customer’s activity window into **all calendar days**
--    between their first & last transaction dates
WITH bounds AS (
  SELECT
    "customer_id",
    MIN(TO_DATE("txn_date")) AS "start_dt",
    MAX(TO_DATE("txn_date")) AS "end_dt"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
  GROUP BY "customer_id"
), calendar AS (
  SELECT
    b."customer_id",
    DATEADD(day, seq4(), b."start_dt") AS "calendar_dt"
  FROM bounds b,
       TABLE(GENERATOR(ROWCOUNT => 3650))          -- sufficient length
  WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
)
SELECT * FROM calendar
LIMIT 20;
Results:
customer_id,calendar_dt
429,2020-01-21
155,2020-01-11
398,2020-01-03
255,2020-01-17
185,2020-02-02
309,2020-01-18
312,2020-01-26
376,2020-01-10
188,2020-01-21
138,2020-01-20
373,2020-01-28
169,2020-01-21
402,2020-01-17
383,2020-02-08
499,2020-01-16
441,2020-01-27

[Successfully executed]
2025-05-07 07:05:17 - Thread-615 (execute) - INFO - [Try to execute]
-- 6) Bring in the running balances (from Query-4) onto the full calendar,
--    then carry the previous balance forward to fill missing-day gaps
WITH txns AS (
  SELECT
    "customer_id",
    TO_DATE("txn_date") AS "txn_date",
    CASE WHEN "txn_type" ILIKE 'deposit' 
         THEN "txn_amount" 
         ELSE -1 * "txn_amount" END AS "signed_amount"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), daily_running AS (
  SELECT
    "customer_id",
    "txn_date",
    SUM("signed_amount")
      OVER (PARTITION BY "customer_id"
            ORDER BY "txn_date"
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
  FROM txns
), bounds AS (
  SELECT
    "customer_id",
    MIN("txn_date") AS "start_dt",
    MAX("txn_date") AS "end_dt"
  FROM daily_running
  GROUP BY "customer_id"
), calendar AS (
  SELECT
    b."customer_id",
    DATEADD(day, seq4(), b."start_dt") AS "calendar_dt"
  FROM bounds b,
       TABLE(GENERATOR(ROWCOUNT => 3650))
  WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (
  SELECT
    c."customer_id",
    c."calendar_dt",
    d."running_balance"
  FROM calendar c
  LEFT JOIN daily_running d
        ON c."customer_id" = d."customer_id"
       AND c."calendar_dt" = d."txn_date"
), filled AS (
  SELECT
    "customer_id",
    "calendar_dt",
    COALESCE(
      LAST_VALUE("running_balance") 
        IGNORE NULLS
        OVER (PARTITION BY "customer_id" 
              ORDER BY "calendar_dt"),
      0
    ) AS "daily_balance"
  FROM joined
)
SELECT * FROM filled
LIMIT 20;
[Try to execute]
2025-05-07 07:05:17 - Thread-615 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
-- 6) Bring in the running balances (from Query-4) onto the full calendar,
--    then carry the previous balance forward to fill missing-day gaps
WITH txns AS (
  SELECT
    "customer_id",
    TO_DATE("txn_date") AS "txn_date",
    CASE WHEN "txn_type" ILIKE 'deposit' 
         THEN "txn_amount" 
         ELSE -1 * "txn_amount" END AS "signed_amount"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), daily_running AS (
  SELECT
    "customer_id",
    "txn_date",
    SUM("signed_amount")
      OVER (PARTITION BY "customer_id"
            ORDER BY "txn_date"
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
  FROM txns
), bounds AS (
  SELECT
    "customer_id",
    MIN("txn_date") AS "start_dt",
    MAX("txn_date") AS "end_dt"
  FROM daily_running
  GROUP BY "customer_id"
), calendar AS (
  SELECT
    b."customer_id",
    DATEADD(day, seq4(), b."start_dt") AS "calendar_dt"
  FROM bounds b,
       TABLE(GENERATOR(ROWCOUNT => 3650))
  WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (
  SELECT
    c."customer_id",
    c."calendar_dt",
    d."running_balance"
  FROM calendar c
  LEFT JOIN daily_running d
        ON c."customer_id" = d."customer_id"
       AND c."calendar_dt" = d."txn_date"
), filled AS (
  SELECT
    "customer_id",
    "calendar_dt",
    COALESCE(
      LAST_VALUE("running_balance") 
        IGNORE NULLS
        OVER (PARTITION BY "customer_id" 
              ORDER BY "calendar_dt"),
      0
    ) AS "daily_balance"
  FROM joined
)
SELECT * FROM filled
LIMIT 20;
Results:
customer_id,calendar_dt,daily_balance
266,2020-01-20,651
12,2020-02-01,0
37,2020-03-04,848
321,2020-03-15,0
345,2020-03-08,-1586
266,2020-01-22,651
12,2020-02-03,0
37,2020-03-06,848
321,2020-03-17,0
345,2020-03-10,-1586
324,2020-01-16,0
367,2020-02-26,-467
366,2020-03-05,-783
224,2020-03-21,0

[Successfully executed]
2025-05-07 07:05:17 - Thread-615 (execute) - INFO - [Try to execute]
-- 7) Replace any negative daily balances with zero (per requirement)
WITH filled AS (  /* replicate Query-6 logic until daily balances step */ 
  SELECT
    j."customer_id",
    j."calendar_dt",
    COALESCE(
      LAST_VALUE(j."running_balance") 
        IGNORE NULLS
        OVER (PARTITION BY j."customer_id" 
              ORDER BY j."calendar_dt"),
      0
    ) AS "daily_balance"
  FROM (
        /* calendar-plus-running logic abbreviated for brevity */
        SELECT
          c."customer_id",
          c."calendar_dt",
          d."running_balance"
        FROM (
              /* calendar build */
              SELECT
                b."customer_id",
                DATEADD(day, seq4(), b."start_dt") AS "calendar_dt"
              FROM (
                    SELECT
                      "customer_id",
                      MIN(TO_DATE("txn_date")) AS "start_dt",
                      MAX(TO_DATE("txn_date")) AS "end_dt"
                    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
                    GROUP BY "customer_id"
              ) b,
              TABLE(GENERATOR(ROWCOUNT => 3650))
              WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
          ) c
          LEFT JOIN (
              /* running balance */
              SELECT
                "customer_id",
                TO_DATE("txn_date") AS "txn_date",
                SUM(CASE WHEN "txn_type" ILIKE 'deposit' 
                         THEN "txn_amount" 
                         ELSE -1 * "txn_amount" END)
                  OVER (PARTITION BY "customer_id"
                        ORDER BY TO_DATE("txn_date")
                        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
              FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
          ) d
          ON c."customer_id" = d."customer_id" 
         AND c."calendar_dt" = d."txn_date"
    ) j
), clipped AS (
  SELECT
    "customer_id",
    "calendar_dt",
    CASE WHEN "daily_balance" < 0 THEN 0 ELSE "daily_balance" END AS "daily_balance"
  FROM filled
)
SELECT * FROM clipped
LIMIT 20;
[Try to execute]
2025-05-07 07:05:18 - Thread-615 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
-- 7) Replace any negative daily balances with zero (per requirement)
WITH filled AS (  /* replicate Query-6 logic until daily balances step */ 
  SELECT
    j."customer_id",
    j."calendar_dt",
    COALESCE(
      LAST_VALUE(j."running_balance") 
        IGNORE NULLS
        OVER (PARTITION BY j."customer_id" 
              ORDER BY j."calendar_dt"),
      0
    ) AS "daily_balance"
  FROM (
        /* calendar-plus-running logic abbreviated for brevity */
        SELECT
          c."customer_id",
          c."calendar_dt",
          d."running_balance"
        FROM (
              /* calendar build */
              SELECT
                b."customer_id",
                DATEADD(day, seq4(), b."start_dt") AS "calendar_dt"
              FROM (
                    SELECT
                      "customer_id",
                      MIN(TO_DATE("txn_date")) AS "start_dt",
                      MAX(TO_DATE("txn_date")) AS "end_dt"
                    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
                    GROUP BY "customer_id"
              ) b,
              TABLE(GENERATOR(ROWCOUNT => 3650))
              WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
          ) c
          LEFT JOIN (
              /* running balance */
              SELECT
                "customer_id",
                TO_DATE("txn_date") AS "txn_date",
                SUM(CASE WHEN "txn_type" ILIKE 'deposit' 
                         THEN "txn_amount" 
                         ELSE -1 * "txn_amount" END)
                  OVER (PARTITION BY "customer_id"
                        ORDER BY TO_DATE("txn_date")
                        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
              FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
          ) d
          ON c."customer_id" = d."customer_id" 
         AND c."calendar_dt" = d."txn_date"
    ) j
), clipped AS (
  SELECT
    "customer_id",
    "calendar_dt",
    CASE WHEN "daily_balance" < 0 THEN 0 ELSE "daily_balance" END AS "daily_balance"
  FROM filled
)
SELECT * FROM clipped
LIMIT 20;
Results:
customer_id,calendar_dt,daily_balance
100,2020-01-09,1081
50,2020-02-17,0
199,2020-02-24,0
327,2020-03-05,239
344,2020-03-14,1270
100,2020-01-11,1081
50,2020-02-19,0
199,2020-02-26,0
327,2020-03-07,239
344,2020-03-16,1270
100,2020-01-15,1081
50,2020-02-23,0
199,2020-03-01,0
327,2020-03-11,239

[Successfully executed]
2025-05-07 07:05:18 - Thread-615 (execute) - INFO - [Try to execute]
-- 8) For each customer & month, find the highest daily balance in that month
WITH clipped AS ( /* use the result logic from Query-7 */ 
  SELECT
    "customer_id",
    "calendar_dt",
    CASE WHEN "daily_balance" < 0 THEN 0 ELSE "daily_balance" END AS "daily_balance"
  FROM ( /* placeholder for full daily construct */ )
), month_max AS (
  SELECT
    "customer_id",
    TO_CHAR("calendar_dt", 'YYYY-MM') AS "month_id",
    MAX("daily_balance") AS "max_daily_balance"
  FROM clipped
  GROUP BY "customer_id", TO_CHAR("calendar_dt", 'YYYY-MM')
)
SELECT * FROM month_max
LIMIT 20;
[Try to execute]
2025-05-07 07:05:18 - Thread-615 (execute) - INFO - [Error occurred]
{'status': 'error', 'error_msg': "##ERROR##001003 (42000): SQL compilation error:\nsyntax error line 6 at position 52 unexpected ')'."}
[Error occurred]
2025-05-07 07:08:05 - Thread-615 (execute) - INFO - [Corrected SQL]
```sql
--Description:
-- Goal: produce, for every calendar month, the sum of each customer’s highest
--       daily balance that month. Steps performed inside CTE chain:
--   1) Convert each transaction row into a signed amount (+deposit, –others).
--   2) Compute a running balance for every customer on the exact txn dates.
--   3) Determine each customer’s first and last txn date (activity window).
--   4) Build a calendar of every day in that window via GENERATOR.
--   5) Left-join the calendar to running balances, then forward-fill the most
--      recent non-null balance (daily carry-forward).
--   6) Clamp any negative daily balances to zero.
--   7) For every customer-month, take the max daily balance (their “peak”).
--   8) Sum those peaks across all customers to yield the month’s total.
-- The final SELECT lists each month (YYYY-MM) with its “total_peak_balance”.
-- LIMIT 20 just previews the first 20 months.

WITH txns AS (                          /* 1 ─ signed amount per txn date */
    SELECT
        "customer_id",
        TO_DATE("txn_date") AS "txn_dt",
        CASE
            WHEN "txn_type" ILIKE 'deposit' THEN  "txn_amount"
            ELSE                               -1 * "txn_amount"
        END AS "signed_amt"
    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (                         /* 2 ─ running balance on txn days */
    SELECT
        "customer_id",
        "txn_dt",
        SUM("signed_amt") OVER (
            PARTITION BY "customer_id"
            ORDER BY "txn_dt"
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS "run_bal"
    FROM txns
), bounds AS (                          /* 3 ─ first & last txn dates */
    SELECT
        "customer_id",
        MIN("txn_dt") AS "start_dt",
        MAX("txn_dt") AS "end_dt"
    FROM running
    GROUP BY "customer_id"
), cal AS (                             /* 4 ─ expand to every calendar day */
    SELECT
        b."customer_id",
        DATEADD(day, seq4(), b."start_dt") AS "cal_dt"
    FROM bounds b,
         TABLE(GENERATOR(ROWCOUNT => 400))       /* ~13 months span buffer */
    WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (                          /* 5 ─ align calendar with balances */
    SELECT
        c."customer_id",
        c."cal_dt",
        r."run_bal"
    FROM cal c
    LEFT JOIN running r
           ON r."customer_id" = c."customer_id"
          AND r."txn_dt"      = c."cal_dt"
), filled AS (                          /* 5 (cont.) forward-fill balances */
    SELECT
        "customer_id",
        "cal_dt",
        COALESCE(
            LAST_VALUE("run_bal") IGNORE NULLS
                OVER (PARTITION BY "customer_id"
                      ORDER BY "cal_dt"),
            0
        ) AS "daily_bal"
    FROM joined
), clipped AS (                         /* 6 ─ set negatives to zero */
    SELECT
        "customer_id",
        "cal_dt",
        CASE WHEN "daily_bal" < 0 THEN 0 ELSE "daily_bal" END AS "daily_bal_nonneg"
    FROM filled
), peak AS (                            /* 7 ─ customer’s monthly peak */
    SELECT
        "customer_id",
        TO_CHAR("cal_dt", 'YYYY-MM') AS "month_id",
        MAX("daily_bal_nonneg")       AS "peak_bal"
    FROM clipped
    GROUP BY "customer_id", TO_CHAR("cal_dt", 'YYYY-MM')
)
SELECT
    "month_id",
    SUM("peak_bal") AS "total_peak_balance"
FROM peak
GROUP BY "month_id"
ORDER BY "month_id"
LIMIT 20;
```
[Corrected SQL]
2025-05-07 07:08:05 - Thread-615 (execute) - INFO - [Results for corrected sql]
month_id,total_peak_balance
2020-01,2139
2020-02,2139
2020-03,2139

[Results for corrected sql]
2025-05-07 07:09:03 - Thread-615 (execute) - INFO - [Corrected other sqls]
```sql
--Description: 
-- Query 9 – re-creates the full daily-balance logic, derives each customer’s
-- monthly peak balance, then aggregates (sums) those peaks to give the total
-- peak balance per month for all customers.  Preview limited to 20 months.
WITH txns AS (
    SELECT
        "customer_id",
        TO_DATE("txn_date")                                   AS "txn_dt",
        CASE WHEN "txn_type" ILIKE 'deposit'
             THEN  "txn_amount"
             ELSE -1 * "txn_amount" END                      AS "signed_amt"
    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (
    SELECT
        "customer_id",
        "txn_dt",
        SUM("signed_amt") OVER (
             PARTITION BY "customer_id"
             ORDER BY "txn_dt"
             ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        )                                                   AS "run_bal"
    FROM txns
), bounds AS (
    SELECT
        "customer_id",
        MIN("txn_dt")                                       AS "start_dt",
        MAX("txn_dt")                                       AS "end_dt"
    FROM running
    GROUP BY "customer_id"
), cal AS (
    SELECT
        b."customer_id",
        DATEADD(day, seq4(), b."start_dt")                  AS "cal_dt"
    FROM bounds b,
         TABLE(GENERATOR(ROWCOUNT => 1000))
    WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (
    SELECT
        c."customer_id",
        c."cal_dt",
        r."run_bal"
    FROM cal c
    LEFT JOIN running r
           ON r."customer_id" = c."customer_id"
          AND r."txn_dt"      = c."cal_dt"
), filled AS (
    SELECT
        "customer_id",
        "cal_dt",
        COALESCE(
            LAST_VALUE("run_bal") IGNORE NULLS
              OVER (PARTITION BY "customer_id" ORDER BY "cal_dt"),
            0
        )                                                   AS "daily_bal"
    FROM joined
), clipped AS (
    SELECT
        "customer_id",
        "cal_dt",
        CASE WHEN "daily_bal" < 0 THEN 0 ELSE "daily_bal" END
                                                          AS "daily_bal_nonneg"
    FROM filled
), peak AS (
    SELECT
        "customer_id",
        TO_CHAR("cal_dt", 'YYYY-MM')                       AS "month_id",
        MAX("daily_bal_nonneg")                            AS "peak_bal"
    FROM clipped
    GROUP BY "customer_id", TO_CHAR("cal_dt", 'YYYY-MM')
)
SELECT
    "month_id",
    SUM("peak_bal")                                       AS "total_peak_balance"
FROM peak
GROUP BY "month_id"
ORDER BY "month_id"
LIMIT 20;
```

```sql
--Description: 
-- Query 10 – using the same logic, returns the customers who contributed to
-- a selected month’s peak-balance pool (example month: 2020-01) along with
-- each customer’s personal maximum daily balance in that month. Top 20 shown.
WITH txns AS (
    SELECT
        "customer_id",
        TO_DATE("txn_date")                                   AS "txn_dt",
        CASE WHEN "txn_type" ILIKE 'deposit'
             THEN  "txn_amount"
             ELSE -1 * "txn_amount" END                      AS "signed_amt"
    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (
    SELECT
        "customer_id",
        "txn_dt",
        SUM("signed_amt") OVER (
             PARTITION BY "customer_id"
             ORDER BY "txn_dt"
             ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        )                                                   AS "run_bal"
    FROM txns
), bounds AS (
    SELECT
        "customer_id",
        MIN("txn_dt")                                       AS "start_dt",
        MAX("txn_dt")                                       AS "end_dt"
    FROM running
    GROUP BY "customer_id"
), cal AS (
    SELECT
        b."customer_id",
        DATEADD(day, seq4(), b."start_dt")                  AS "cal_dt"
    FROM bounds b,
         TABLE(GENERATOR(ROWCOUNT => 1000))
    WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (
    SELECT
        c."customer_id",
        c."cal_dt",
        r."run_bal"
    FROM cal c
    LEFT JOIN running r
           ON r."customer_id" = c."customer_id"
          AND r."txn_dt"      = c."cal_dt"
), filled AS (
    SELECT
        "customer_id",
        "cal_dt",
        COALESCE(
            LAST_VALUE("run_bal") IGNORE NULLS
              OVER (PARTITION BY "customer_id" ORDER BY "cal_dt"),
            0
        )                                                   AS "daily_bal"
    FROM joined
), clipped AS (
    SELECT
        "customer_id",
        "cal_dt",
        CASE WHEN "daily_bal" < 0 THEN 0 ELSE "daily_bal" END
                                                          AS "daily_bal_nonneg"
    FROM filled
), peak AS (
    SELECT
        "customer_id",
        TO_CHAR("cal_dt", 'YYYY-MM')                       AS "month_id",
        MAX("daily_bal_nonneg")                            AS "peak_bal"
    FROM clipped
    GROUP BY "customer_id", TO_CHAR("cal_dt", 'YYYY-MM')
)
SELECT
    "customer_id",
    "peak_bal"                                            AS "max_daily_balance"
FROM peak
WHERE "month_id" = '2020-01'
ORDER BY "max_daily_balance" DESC
LIMIT 20;
```
[Corrected other sqls]
2025-05-07 07:09:03 - Thread-615 (execute) - INFO - [Successfully corrected]
Successfully corrected. SQL:
--Description:
-- Goal: produce, for every calendar month, the sum of each customer’s highest
--       daily balance that month. Steps performed inside CTE chain:
--   1) Convert each transaction row into a signed amount (+deposit, –others).
--   2) Compute a running balance for every customer on the exact txn dates.
--   3) Determine each customer’s first and last txn date (activity window).
--   4) Build a calendar of every day in that window via GENERATOR.
--   5) Left-join the calendar to running balances, then forward-fill the most
--      recent non-null balance (daily carry-forward).
--   6) Clamp any negative daily balances to zero.
--   7) For every customer-month, take the max daily balance (their “peak”).
--   8) Sum those peaks across all customers to yield the month’s total.
-- The final SELECT lists each month (YYYY-MM) with its “total_peak_balance”.
-- LIMIT 20 just previews the first 20 months.

WITH txns AS (                          /* 1 ─ signed amount per txn date */
    SELECT
        "customer_id",
        TO_DATE("txn_date") AS "txn_dt",
        CASE
            WHEN "txn_type" ILIKE 'deposit' THEN  "txn_amount"
            ELSE                               -1 * "txn_amount"
        END AS "signed_amt"
    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (                         /* 2 ─ running balance on txn days */
    SELECT
        "customer_id",
        "txn_dt",
        SUM("signed_amt") OVER (
            PARTITION BY "customer_id"
            ORDER BY "txn_dt"
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        ) AS "run_bal"
    FROM txns
), bounds AS (                          /* 3 ─ first & last txn dates */
    SELECT
        "customer_id",
        MIN("txn_dt") AS "start_dt",
        MAX("txn_dt") AS "end_dt"
    FROM running
    GROUP BY "customer_id"
), cal AS (                             /* 4 ─ expand to every calendar day */
    SELECT
        b."customer_id",
        DATEADD(day, seq4(), b."start_dt") AS "cal_dt"
    FROM bounds b,
         TABLE(GENERATOR(ROWCOUNT => 400))       /* ~13 months span buffer */
    WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (                          /* 5 ─ align calendar with balances */
    SELECT
        c."customer_id",
        c."cal_dt",
        r."run_bal"
    FROM cal c
    LEFT JOIN running r
           ON r."customer_id" = c."customer_id"
          AND r."txn_dt"      = c."cal_dt"
), filled AS (                          /* 5 (cont.) forward-fill balances */
    SELECT
        "customer_id",
        "cal_dt",
        COALESCE(
            LAST_VALUE("run_bal") IGNORE NULLS
                OVER (PARTITION BY "customer_id"
                      ORDER BY "cal_dt"),
            0
        ) AS "daily_bal"
    FROM joined
), clipped AS (                         /* 6 ─ set negatives to zero */
    SELECT
        "customer_id",
        "cal_dt",
        CASE WHEN "daily_bal" < 0 THEN 0 ELSE "daily_bal" END AS "daily_bal_nonneg"
    FROM filled
), peak AS (                            /* 7 ─ customer’s monthly peak */
    SELECT
        "customer_id",
        TO_CHAR("cal_dt", 'YYYY-MM') AS "month_id",
        MAX("daily_bal_nonneg")       AS "peak_bal"
    FROM clipped
    GROUP BY "customer_id", TO_CHAR("cal_dt", 'YYYY-MM')
)
SELECT
    "month_id",
    SUM("peak_bal") AS "total_peak_balance"
FROM peak
GROUP BY "month_id"
ORDER BY "month_id"
LIMIT 20;
Results:
month_id,total_peak_balance
2020-01,2139
2020-02,2139
2020-03,2139

[Successfully corrected]
2025-05-07 07:09:03 - Thread-615 (execute) - INFO - [Try to execute]
--Description: 
-- Query 9 – re-creates the full daily-balance logic, derives each customer’s
-- monthly peak balance, then aggregates (sums) those peaks to give the total
-- peak balance per month for all customers.  Preview limited to 20 months.
WITH txns AS (
    SELECT
        "customer_id",
        TO_DATE("txn_date")                                   AS "txn_dt",
        CASE WHEN "txn_type" ILIKE 'deposit'
             THEN  "txn_amount"
             ELSE -1 * "txn_amount" END                      AS "signed_amt"
    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (
    SELECT
        "customer_id",
        "txn_dt",
        SUM("signed_amt") OVER (
             PARTITION BY "customer_id"
             ORDER BY "txn_dt"
             ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        )                                                   AS "run_bal"
    FROM txns
), bounds AS (
    SELECT
        "customer_id",
        MIN("txn_dt")                                       AS "start_dt",
        MAX("txn_dt")                                       AS "end_dt"
    FROM running
    GROUP BY "customer_id"
), cal AS (
    SELECT
        b."customer_id",
        DATEADD(day, seq4(), b."start_dt")                  AS "cal_dt"
    FROM bounds b,
         TABLE(GENERATOR(ROWCOUNT => 1000))
    WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (
    SELECT
        c."customer_id",
        c."cal_dt",
        r."run_bal"
    FROM cal c
    LEFT JOIN running r
           ON r."customer_id" = c."customer_id"
          AND r."txn_dt"      = c."cal_dt"
), filled AS (
    SELECT
        "customer_id",
        "cal_dt",
        COALESCE(
            LAST_VALUE("run_bal") IGNORE NULLS
              OVER (PARTITION BY "customer_id" ORDER BY "cal_dt"),
            0
        )                                                   AS "daily_bal"
    FROM joined
), clipped AS (
    SELECT
        "customer_id",
        "cal_dt",
        CASE WHEN "daily_bal" < 0 THEN 0 ELSE "daily_bal" END
                                                          AS "daily_bal_nonneg"
    FROM filled
), peak AS (
    SELECT
        "customer_id",
        TO_CHAR("cal_dt", 'YYYY-MM')                       AS "month_id",
        MAX("daily_bal_nonneg")                            AS "peak_bal"
    FROM clipped
    GROUP BY "customer_id", TO_CHAR("cal_dt", 'YYYY-MM')
)
SELECT
    "month_id",
    SUM("peak_bal")                                       AS "total_peak_balance"
FROM peak
GROUP BY "month_id"
ORDER BY "month_id"
LIMIT 20
[Try to execute]
2025-05-07 07:09:04 - Thread-615 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
--Description: 
-- Query 9 – re-creates the full daily-balance logic, derives each customer’s
-- monthly peak balance, then aggregates (sums) those peaks to give the total
-- peak balance per month for all customers.  Preview limited to 20 months.
WITH txns AS (
    SELECT
        "customer_id",
        TO_DATE("txn_date")                                   AS "txn_dt",
        CASE WHEN "txn_type" ILIKE 'deposit'
             THEN  "txn_amount"
             ELSE -1 * "txn_amount" END                      AS "signed_amt"
    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (
    SELECT
        "customer_id",
        "txn_dt",
        SUM("signed_amt") OVER (
             PARTITION BY "customer_id"
             ORDER BY "txn_dt"
             ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        )                                                   AS "run_bal"
    FROM txns
), bounds AS (
    SELECT
        "customer_id",
        MIN("txn_dt")                                       AS "start_dt",
        MAX("txn_dt")                                       AS "end_dt"
    FROM running
    GROUP BY "customer_id"
), cal AS (
    SELECT
        b."customer_id",
        DATEADD(day, seq4(), b."start_dt")                  AS "cal_dt"
    FROM bounds b,
         TABLE(GENERATOR(ROWCOUNT => 1000))
    WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (
    SELECT
        c."customer_id",
        c."cal_dt",
        r."run_bal"
    FROM cal c
    LEFT JOIN running r
           ON r."customer_id" = c."customer_id"
          AND r."txn_dt"      = c."cal_dt"
), filled AS (
    SELECT
        "customer_id",
        "cal_dt",
        COALESCE(
            LAST_VALUE("run_bal") IGNORE NULLS
              OVER (PARTITION BY "customer_id" ORDER BY "cal_dt"),
            0
        )                                                   AS "daily_bal"
    FROM joined
), clipped AS (
    SELECT
        "customer_id",
        "cal_dt",
        CASE WHEN "daily_bal" < 0 THEN 0 ELSE "daily_bal" END
                                                          AS "daily_bal_nonneg"
    FROM filled
), peak AS (
    SELECT
        "customer_id",
        TO_CHAR("cal_dt", 'YYYY-MM')                       AS "month_id",
        MAX("daily_bal_nonneg")                            AS "peak_bal"
    FROM clipped
    GROUP BY "customer_id", TO_CHAR("cal_dt", 'YYYY-MM')
)
SELECT
    "month_id",
    SUM("peak_bal")                                       AS "total_peak_balance"
FROM peak
GROUP BY "month_id"
ORDER BY "month_id"
LIMIT 20
Results:
month_id,total_peak_balance
2020-01,5967
2020-02,5967
2020-03,5967
2020-04,4815

[Successfully executed]
2025-05-07 07:09:04 - Thread-615 (execute) - INFO - [Try to execute]
--Description: 
-- Query 10 – using the same logic, returns the customers who contributed to
-- a selected month’s peak-balance pool (example month: 2020-01) along with
-- each customer’s personal maximum daily balance in that month. Top 20 shown.
WITH txns AS (
    SELECT
        "customer_id",
        TO_DATE("txn_date")                                   AS "txn_dt",
        CASE WHEN "txn_type" ILIKE 'deposit'
             THEN  "txn_amount"
             ELSE -1 * "txn_amount" END                      AS "signed_amt"
    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (
    SELECT
        "customer_id",
        "txn_dt",
        SUM("signed_amt") OVER (
             PARTITION BY "customer_id"
             ORDER BY "txn_dt"
             ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        )                                                   AS "run_bal"
    FROM txns
), bounds AS (
    SELECT
        "customer_id",
        MIN("txn_dt")                                       AS "start_dt",
        MAX("txn_dt")                                       AS "end_dt"
    FROM running
    GROUP BY "customer_id"
), cal AS (
    SELECT
        b."customer_id",
        DATEADD(day, seq4(), b."start_dt")                  AS "cal_dt"
    FROM bounds b,
         TABLE(GENERATOR(ROWCOUNT => 1000))
    WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (
    SELECT
        c."customer_id",
        c."cal_dt",
        r."run_bal"
    FROM cal c
    LEFT JOIN running r
           ON r."customer_id" = c."customer_id"
          AND r."txn_dt"      = c."cal_dt"
), filled AS (
    SELECT
        "customer_id",
        "cal_dt",
        COALESCE(
            LAST_VALUE("run_bal") IGNORE NULLS
              OVER (PARTITION BY "customer_id" ORDER BY "cal_dt"),
            0
        )                                                   AS "daily_bal"
    FROM joined
), clipped AS (
    SELECT
        "customer_id",
        "cal_dt",
        CASE WHEN "daily_bal" < 0 THEN 0 ELSE "daily_bal" END
                                                          AS "daily_bal_nonneg"
    FROM filled
), peak AS (
    SELECT
        "customer_id",
        TO_CHAR("cal_dt", 'YYYY-MM')                       AS "month_id",
        MAX("daily_bal_nonneg")                            AS "peak_bal"
    FROM clipped
    GROUP BY "customer_id", TO_CHAR("cal_dt", 'YYYY-MM')
)
SELECT
    "customer_id",
    "peak_bal"                                            AS "max_daily_balance"
FROM peak
WHERE "month_id" = '2020-01'
ORDER BY "max_daily_balance" DESC
LIMIT 20
[Try to execute]
2025-05-07 07:09:05 - Thread-615 (execute) - INFO - [Successfully executed]
Successfully executed. SQL:
--Description: 
-- Query 10 – using the same logic, returns the customers who contributed to
-- a selected month’s peak-balance pool (example month: 2020-01) along with
-- each customer’s personal maximum daily balance in that month. Top 20 shown.
WITH txns AS (
    SELECT
        "customer_id",
        TO_DATE("txn_date")                                   AS "txn_dt",
        CASE WHEN "txn_type" ILIKE 'deposit'
             THEN  "txn_amount"
             ELSE -1 * "txn_amount" END                      AS "signed_amt"
    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (
    SELECT
        "customer_id",
        "txn_dt",
        SUM("signed_amt") OVER (
             PARTITION BY "customer_id"
             ORDER BY "txn_dt"
             ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        )                                                   AS "run_bal"
    FROM txns
), bounds AS (
    SELECT
        "customer_id",
        MIN("txn_dt")                                       AS "start_dt",
        MAX("txn_dt")                                       AS "end_dt"
    FROM running
    GROUP BY "customer_id"
), cal AS (
    SELECT
        b."customer_id",
        DATEADD(day, seq4(), b."start_dt")                  AS "cal_dt"
    FROM bounds b,
         TABLE(GENERATOR(ROWCOUNT => 1000))
    WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (
    SELECT
        c."customer_id",
        c."cal_dt",
        r."run_bal"
    FROM cal c
    LEFT JOIN running r
           ON r."customer_id" = c."customer_id"
          AND r."txn_dt"      = c."cal_dt"
), filled AS (
    SELECT
        "customer_id",
        "cal_dt",
        COALESCE(
            LAST_VALUE("run_bal") IGNORE NULLS
              OVER (PARTITION BY "customer_id" ORDER BY "cal_dt"),
            0
        )                                                   AS "daily_bal"
    FROM joined
), clipped AS (
    SELECT
        "customer_id",
        "cal_dt",
        CASE WHEN "daily_bal" < 0 THEN 0 ELSE "daily_bal" END
                                                          AS "daily_bal_nonneg"
    FROM filled
), peak AS (
    SELECT
        "customer_id",
        TO_CHAR("cal_dt", 'YYYY-MM')                       AS "month_id",
        MAX("daily_bal_nonneg")                            AS "peak_bal"
    FROM clipped
    GROUP BY "customer_id", TO_CHAR("cal_dt", 'YYYY-MM')
)
SELECT
    "customer_id",
    "peak_bal"                                            AS "max_daily_balance"
FROM peak
WHERE "month_id" = '2020-01'
ORDER BY "max_daily_balance" DESC
LIMIT 20
Results:
customer_id,max_daily_balance
468,939
378,0
195,0
180,0
308,0

[Successfully executed]
2025-05-07 07:09:05 - Thread-615 (execute) - INFO - itercount: 0
2025-05-07 07:09:05 - Thread-615 (execute) - INFO - [Self-refine]
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.INTEREST_MAP
Column name: interest_summary Type: TEXT
Column name: id Type: NUMBER
Column name: interest_name Type: TEXT
Column name: last_modified Type: TEXT
Column name: created_at Type: TEXT
Sample rows:
[{'id': 4, 'interest_name': 'Luxury Retail Researchers', 'interest_summary': 'Consumers researching luxury product reviews and gift ideas.', 'created_at': '2016-05-26 14:57:59', 'last_modified': '2018-05-23 11:30:12'}, {'id': 6, 'interest_name': 'Vacation Planners', 'interest_summary': 'Consumers reading reviews of vacation destinations and accommodations.', 'created_at': '2016-05-26 14:57:59', 'last_modified': '2018-05-23 11:30:13'}, {'id': 7, 'interest_name': 'Motorcycle Enthusiasts', 'interest_summary': 'Readers of motorcycle news and reviews.', 'created_at': '2016-05-26 14:57:59', 'last_modified': '2018-05-23 11:30:13'}, {'id': 8, 'interest_name': 'Business News Readers', 'interest_summary': 'Readers of online business news content.', 'created_at': '2016-05-26 14:57:59', 'last_modified': '2018-05-23 11:30:12'}, {'id': 13, 'interest_name': 'Advertising Professionals', 'interest_summary': 'People who read advertising industry news.', 'created_at': '2016-05-26 14:57:59', 'last_modified': '2018-05-23 11:30:12'}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.INTEREST_METRICS
Column name: ranking Type: NUMBER
Column name: percentile_ranking Type: FLOAT
Column name: month_year Type: TEXT
Column name: interest_id Type: FLOAT
Column name: composition Type: FLOAT
Column name: _month Type: FLOAT
Column name: index_value Type: FLOAT
Column name: _year Type: FLOAT
Sample rows:
[{'_month': 7.0, '_year': 2018.0, 'month_year': '07-2018', 'interest_id': 6106.0, 'composition': 9.93, 'index_value': 5.31, 'ranking': 2, 'percentile_ranking': 99.73}, {'_month': 7.0, '_year': 2018.0, 'month_year': '07-2018', 'interest_id': 18923.0, 'composition': 10.85, 'index_value': 5.29, 'ranking': 3, 'percentile_ranking': 99.59}, {'_month': 7.0, '_year': 2018.0, 'month_year': '07-2018', 'interest_id': 6344.0, 'composition': 10.32, 'index_value': 5.1, 'ranking': 4, 'percentile_ranking': 99.45}, {'_month': 7.0, '_year': 2018.0, 'month_year': '07-2018', 'interest_id': 100.0, 'composition': 10.77, 'index_value': 5.04, 'ranking': 5, 'percentile_ranking': 99.31}, {'_month': 7.0, '_year': 2018.0, 'month_year': '07-2018', 'interest_id': 79.0, 'composition': 11.21, 'index_value': 4.97, 'ranking': 7, 'percentile_ranking': 99.04}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.BITCOIN_PRICES
Column name: low Type: FLOAT
Column name: change Type: TEXT
Column name: price Type: FLOAT
Column name: open Type: FLOAT
Column name: volume Type: TEXT
Column name: high Type: FLOAT
Column name: market_date Type: TEXT
Column name: ticker Type: TEXT
Sample rows:
[{'ticker': 'ETH', 'market_date': '29-08-2021', 'price': 3177.84, 'open': 3243.96, 'high': 3282.21, 'low': 3162.79, 'volume': '582.04K', 'change': '-2.04%'}, {'ticker': 'ETH', 'market_date': '27-08-2021', 'price': 3273.58, 'open': 3093.78, 'high': 3279.93, 'low': 3063.37, 'volume': '839.54K', 'change': '5.82%'}, {'ticker': 'ETH', 'market_date': '26-08-2021', 'price': 3093.54, 'open': 3228.03, 'high': 3249.62, 'low': 3057.48, 'volume': '118.44K', 'change': '-4.17%'}, {'ticker': 'ETH', 'market_date': '24-08-2021', 'price': 3173.26, 'open': 3322.6, 'high': 3357.99, 'low': 3150.75, 'volume': '988.82K', 'change': '-4.41%'}, {'ticker': 'ETH', 'market_date': '23-08-2021', 'price': 3319.49, 'open': 3238.41, 'high': 3375.42, 'low': 3231.96, 'volume': '1.09M', 'change': '2.49%'}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.SHOPPING_CART_CAMPAIGN_IDENTIFIER
Column name: start_date Type: TEXT
Column name: campaign_id Type: NUMBER
Column name: campaign_name Type: TEXT
Column name: end_date Type: TEXT
Column name: products Type: TEXT
Sample rows:
[]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.SHOPPING_CART_EVENT_IDENTIFIER
Column name: event_name Type: TEXT
Column name: event_type Type: NUMBER
Sample rows:
[{'event_type': 2, 'event_name': 'Add to Cart'}, {'event_type': 3, 'event_name': 'Purchase'}, {'event_type': 4, 'event_name': 'Ad Impression'}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.VEG_CAT
Column name: category_code Type: NUMBER
Column name: item_code Type: NUMBER
Column name: category_name Type: TEXT
Column name: item_name Type: TEXT
Column name: index Type: NUMBER
Sample rows:
[{'index': 0, 'item_code': 102900005115168, 'item_name': 'Niushou Shengcai', 'category_code': 1011010101, 'category_name': 'Flower/Leaf\xa0Vegetables'}, {'index': 2, 'item_code': 102900005115625, 'item_name': 'Local Xiaomao Cabbage', 'category_code': 1011010101, 'category_name': 'Flower/Leaf\xa0Vegetables'}, {'index': 3, 'item_code': 102900005115748, 'item_name': 'White Caitai', 'category_code': 1011010101, 'category_name': 'Flower/Leaf\xa0Vegetables'}, {'index': 4, 'item_code': 102900005115762, 'item_name': 'Amaranth', 'category_code': 1011010101, 'category_name': 'Flower/Leaf\xa0Vegetables'}, {'index': 5, 'item_code': 102900005115779, 'item_name': 'Yunnan Shengcai', 'category_code': 1011010101, 'category_name': 'Flower/Leaf\xa0Vegetables'}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.VEG_WHSLE_DF
Column name: index Type: NUMBER
Column name: whsle_px_rmb-kg Type: FLOAT
Column name: whsle_date Type: TEXT
Column name: item_code Type: NUMBER
Sample rows:
[{'index': 0, 'whsle_date': '2020-07-01 00:00:00', 'item_code': 102900005115762, 'whsle_px_rmb-kg': 3.88}, {'index': 5, 'whsle_date': '2020-07-01 00:00:00', 'item_code': 102900005115908, 'whsle_px_rmb-kg': 4.6}, {'index': 8, 'whsle_date': '2020-07-01 00:00:00', 'item_code': 102900005115984, 'whsle_px_rmb-kg': 3.44}, {'index': 9, 'whsle_date': '2020-07-01 00:00:00', 'item_code': 102900005116226, 'whsle_px_rmb-kg': 4.64}, {'index': 10, 'whsle_date': '2020-07-01 00:00:00', 'item_code': 102900005116233, 'whsle_px_rmb-kg': 5.76}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.BITCOIN_TRANSACTIONS
Column name: quantity Type: FLOAT
Column name: member_id Type: TEXT
Column name: txn_id Type: NUMBER
Column name: ticker Type: TEXT
Column name: txn_type Type: TEXT
Column name: percentage_fee Type: FLOAT
Column name: txn_time Type: TEXT
Column name: txn_date Type: TEXT
Sample rows:
[{'txn_id': 2, 'member_id': 'eccbc8', 'ticker': 'BTC', 'txn_date': '01-01-2017', 'txn_type': 'BUY', 'quantity': 50.0, 'percentage_fee': 0.3, 'txn_time': '2017-01-01T00:00:00.000Z'}, {'txn_id': 3, 'member_id': 'a87ff6', 'ticker': 'BTC', 'txn_date': '01-01-2017', 'txn_type': 'BUY', 'quantity': 50.0, 'percentage_fee': 0.0, 'txn_time': '2017-01-01T00:00:00.000Z'}, {'txn_id': 7, 'member_id': '8f14e4', 'ticker': 'BTC', 'txn_date': '01-01-2017', 'txn_type': 'BUY', 'quantity': 50.0, 'percentage_fee': 0.21, 'txn_time': '2017-01-01T00:00:00.000Z'}, {'txn_id': 8, 'member_id': 'c9f0f8', 'ticker': 'BTC', 'txn_date': '01-01-2017', 'txn_type': 'BUY', 'quantity': 50.0, 'percentage_fee': 0.3, 'txn_time': '2017-01-01T00:00:00.000Z'}, {'txn_id': 10, 'member_id': 'd3d944', 'ticker': 'BTC', 'txn_date': '01-01-2017', 'txn_type': 'BUY', 'quantity': 50.0, 'percentage_fee': 0.3, 'txn_time': '2017-01-01T00:00:00.000Z'}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.SHOPPING_CART_EVENTS
Column name: page_id Type: NUMBER
Column name: event_type Type: NUMBER
Column name: cookie_id Type: TEXT
Column name: event_time Type: TEXT
Column name: visit_id Type: TEXT
Column name: sequence_number Type: NUMBER
Sample rows:
[{'visit_id': 'ccf365', 'cookie_id': 'c4ca42', 'page_id': 9, 'event_type': 1, 'sequence_number': 4, 'event_time': '2020-02-04 19:16:58.609142'}, {'visit_id': 'ccf365', 'cookie_id': 'c4ca42', 'page_id': 9, 'event_type': 2, 'sequence_number': 5, 'event_time': '2020-02-04 19:17:51.72942'}, {'visit_id': 'ccf365', 'cookie_id': 'c4ca42', 'page_id': 10, 'event_type': 2, 'sequence_number': 7, 'event_time': '2020-02-04 19:19:10.570786'}, {'visit_id': 'ccf365', 'cookie_id': 'c4ca42', 'page_id': 12, 'event_type': 1, 'sequence_number': 10, 'event_time': '2020-02-04 19:20:52.307244'}, {'visit_id': 'd58cbd', 'cookie_id': 'c81e72', 'page_id': 1, 'event_type': 1, 'sequence_number': 1, 'event_time': '2020-01-18 23:40:54.761906'}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.VEG_LOSS_RATE_DF
Column name: item_name Type: TEXT
Column name: item_code Type: NUMBER
Column name: index Type: NUMBER
Column name: loss_rate_% Type: FLOAT
Sample rows:
[{'index': 0, 'item_code': 102900005115168, 'item_name': 'Niushou Shengcai', 'loss_rate_%': 4.39}, {'index': 1, 'item_code': 102900005115199, 'item_name': 'Sichuan Red Cedar', 'loss_rate_%': 10.46}, {'index': 7, 'item_code': 102900005115786, 'item_name': 'Zhuyecai', 'loss_rate_%': 13.62}, {'index': 8, 'item_code': 102900005115793, 'item_name': 'Chinese Cabbage', 'loss_rate_%': 7.59}, {'index': 10, 'item_code': 102900005115823, 'item_name': 'Shanghaiqing', 'loss_rate_%': 14.43}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_NODES
Column name: region_id Type: NUMBER
Column name: start_date Type: TEXT
Column name: end_date Type: TEXT
Column name: customer_id Type: NUMBER
Column name: node_id Type: NUMBER
Sample rows:
[{'customer_id': 1, 'region_id': 3, 'node_id': 4, 'start_date': '2020-01-02', 'end_date': '2020-01-03'}, {'customer_id': 2, 'region_id': 3, 'node_id': 5, 'start_date': '2020-01-03', 'end_date': '2020-01-17'}, {'customer_id': 3, 'region_id': 5, 'node_id': 4, 'start_date': '2020-01-27', 'end_date': '2020-02-18'}, {'customer_id': 4, 'region_id': 5, 'node_id': 4, 'start_date': '2020-01-07', 'end_date': '2020-01-19'}, {'customer_id': 7, 'region_id': 2, 'node_id': 5, 'start_date': '2020-01-20', 'end_date': '2020-02-04'}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.WEEKLY_SALES
Column name: region Type: TEXT
Column name: week_date Type: TEXT
Column name: segment Type: TEXT
Column name: customer_type Type: TEXT
Column name: sales Type: NUMBER
Column name: platform Type: TEXT
Column name: transactions Type: NUMBER
Sample rows:
[{'week_date': '31/8/20', 'region': 'ASIA', 'platform': 'Retail', 'segment': 'F1', 'customer_type': 'New', 'transactions': 31574, 'sales': 996575}, {'week_date': '31/8/20', 'region': 'OCEANIA', 'platform': 'Shopify', 'segment': 'C2', 'customer_type': 'Existing', 'transactions': 4661, 'sales': 882690}, {'week_date': '31/8/20', 'region': 'AFRICA', 'platform': 'Retail', 'segment': 'F1', 'customer_type': 'Existing', 'transactions': 97604, 'sales': 5185233}, {'week_date': '31/8/20', 'region': 'OCEANIA', 'platform': 'Retail', 'segment': 'C2', 'customer_type': 'New', 'transactions': 111219, 'sales': 2980673}, {'week_date': '31/8/20', 'region': 'AFRICA', 'platform': 'Retail', 'segment': 'C3', 'customer_type': 'Existing', 'transactions': 284971, 'sales': 14430196}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.BITCOIN_MEMBERS
Column name: first_name Type: TEXT
Column name: member_id Type: TEXT
Column name: region Type: TEXT
Sample rows:
[{'member_id': 'c4ca42', 'first_name': 'Danny', 'region': 'Australia'}, {'member_id': 'c81e72', 'first_name': 'Vipul', 'region': 'United States'}, {'member_id': 'a87ff6', 'first_name': 'Nandita', 'region': 'United States'}, {'member_id': 'e4da3b', 'first_name': 'Rowan', 'region': 'United States'}, {'member_id': '167909', 'first_name': 'Ayush', 'region': 'United States'}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.CLEANED_WEEKLY_SALES
Column name: platform Type: TEXT
Column name: month_number Type: NUMBER
Column name: age_band Type: TEXT
Column name: calendar_year Type: NUMBER
Column name: customer_type Type: TEXT
Column name: region Type: TEXT
Column name: demographic Type: TEXT
Column name: week_number Type: NUMBER
Column name: transactions Type: NUMBER
Column name: avg_transaction Type: FLOAT
Column name: segment Type: TEXT
Column name: week_date Type: TEXT
Column name: sales Type: NUMBER
Column name: week_date_formatted Type: TEXT
Sample rows:
[{'week_date_formatted': '2020-8-31', 'week_date': '2020-08-31', 'region': 'USA', 'platform': 'Retail', 'segment': 'unknown', 'customer_type': 'Guest', 'transactions': 529151, 'sales': 16509610, 'week_number': 36, 'month_number': 8, 'calendar_year': 2020, 'age_band': 'unknown', 'demographic': 'unknown', 'avg_transaction': 31.2}, {'week_date_formatted': '2020-8-31', 'week_date': '2020-08-31', 'region': 'EUROPE', 'platform': 'Retail', 'segment': 'C1', 'customer_type': 'New', 'transactions': 4517, 'sales': 141942, 'week_number': 36, 'month_number': 8, 'calendar_year': 2020, 'age_band': 'Young Adults', 'demographic': 'Couples', 'avg_transaction': 31.42}, {'week_date_formatted': '2020-8-31', 'week_date': '2020-08-31', 'region': 'AFRICA', 'platform': 'Retail', 'segment': 'C2', 'customer_type': 'New', 'transactions': 58046, 'sales': 1758388, 'week_number': 36, 'month_number': 8, 'calendar_year': 2020, 'age_band': 'Middle Aged', 'demographic': 'Couples', 'avg_transaction': 30.29}, {'week_date_formatted': '2020-8-31', 'week_date': '2020-08-31', 'region': 'AFRICA', 'platform': 'Shopify', 'segment': 'F3', 'customer_type': 'Existing', 'transactions': 2514, 'sales': 519502, 'week_number': 36, 'month_number': 8, 'calendar_year': 2020, 'age_band': 'Retirees', 'demographic': 'Families', 'avg_transaction': 206.64}, {'week_date_formatted': '2020-8-31', 'week_date': '2020-08-31', 'region': 'ASIA', 'platform': 'Shopify', 'segment': 'F1', 'customer_type': 'Existing', 'transactions': 2158, 'sales': 371417, 'week_number': 36, 'month_number': 8, 'calendar_year': 2020, 'age_band': 'Young Adults', 'demographic': 'Families', 'avg_transaction': 172.11}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_REGIONS
Column name: region_id Type: NUMBER
Column name: region_name Type: TEXT
Sample rows:
[{'region_id': 3, 'region_name': 'Africa'}, {'region_id': 4, 'region_name': 'Asia'}, {'region_id': 5, 'region_name': 'Europe'}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
Column name: customer_id Type: NUMBER
Column name: txn_date Type: TEXT
Column name: txn_amount Type: NUMBER
Column name: txn_type Type: TEXT
Sample rows:
[{'customer_id': 429, 'txn_date': '2020-01-21', 'txn_type': 'deposit', 'txn_amount': 82}, {'customer_id': 155, 'txn_date': '2020-01-10', 'txn_type': 'deposit', 'txn_amount': 712}, {'customer_id': 398, 'txn_date': '2020-01-01', 'txn_type': 'deposit', 'txn_amount': 196}, {'customer_id': 255, 'txn_date': '2020-01-14', 'txn_type': 'deposit', 'txn_amount': 563}, {'customer_id': 373, 'txn_date': '2020-01-18', 'txn_type': 'deposit', 'txn_amount': 596}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.SHOPPING_CART_USERS
Column name: user_id Type: NUMBER
Column name: cookie_id Type: TEXT
Column name: start_date Type: TEXT
Sample rows:
[{'user_id': 1, 'cookie_id': 'c4ca42', 'start_date': '2020-02-04'}, {'user_id': 2, 'cookie_id': 'c81e72', 'start_date': '2020-01-18'}, {'user_id': 4, 'cookie_id': 'a87ff6', 'start_date': '2020-02-22'}, {'user_id': 5, 'cookie_id': 'e4da3b', 'start_date': '2020-02-01'}, {'user_id': 7, 'cookie_id': '8f14e4', 'start_date': '2020-02-09'}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.VEG_TXN_DF
Column name: txn_date Type: TEXT
Column name: qty_sold(kg) Type: FLOAT
Column name: sale/return Type: TEXT
Column name: txn_time Type: TEXT
Column name: unit_selling_px_rmb/kg Type: FLOAT
Column name: index Type: NUMBER
Column name: discount(%) Type: NUMBER
Column name: item_code Type: NUMBER
Column name: day_of_week Type: TEXT
Sample rows:
[{'index': 1, 'txn_date': '2020-07-01 00:00:00', 'txn_time': '09:17:27', 'item_code': 102900005115960, 'qty_sold(kg)': 0.849, 'unit_selling_px_rmb/kg': 3.2, 'sale/return': 'sale', 'discount(%)': 1, 'day_of_week': 'Wednesday'}, {'index': 6, 'txn_date': '2020-07-01 00:00:00', 'txn_time': '09:21:56', 'item_code': 102900005115779, 'qty_sold(kg)': 0.338, 'unit_selling_px_rmb/kg': 8.0, 'sale/return': 'sale', 'discount(%)': 1, 'day_of_week': 'Wednesday'}, {'index': 7, 'txn_date': '2020-07-01 00:00:00', 'txn_time': '09:22:01', 'item_code': 102900005117056, 'qty_sold(kg)': 0.132, 'unit_selling_px_rmb/kg': 7.6, 'sale/return': 'sale', 'discount(%)': 1, 'day_of_week': 'Wednesday'}, {'index': 8, 'txn_date': '2020-07-01 00:00:00', 'txn_time': '09:22:01', 'item_code': 102900005115779, 'qty_sold(kg)': 0.213, 'unit_selling_px_rmb/kg': 8.0, 'sale/return': 'sale', 'discount(%)': 1, 'day_of_week': 'Wednesday'}, {'index': 9, 'txn_date': '2020-07-01 00:00:00', 'txn_time': '09:22:15', 'item_code': 102900011008522, 'qty_sold(kg)': 0.514, 'unit_selling_px_rmb/kg': 8.0, 'sale/return': 'sale', 'discount(%)': 1, 'day_of_week': 'Wednesday'}]

--------------------------------------------------
Table full name: BANK_SALES_TRADING.BANK_SALES_TRADING.SHOPPING_CART_PAGE_HIERARCHY
Column name: page_id Type: NUMBER
Column name: product_id Type: FLOAT
Column name: page_name Type: TEXT
Column name: product_category Type: TEXT
Sample rows:
[{'page_id': 2, 'page_name': 'All Products', 'product_category': '', 'product_id': nan}, {'page_id': 3, 'page_name': 'Salmon', 'product_category': 'Fish', 'product_id': 1.0}, {'page_id': 4, 'page_name': 'Kingfish', 'product_category': 'Fish', 'product_id': 2.0}, {'page_id': 6, 'page_name': 'Russian Caviar', 'product_category': 'Luxury', 'product_id': 4.0}, {'page_id': 7, 'page_name': 'Black Truffle', 'product_category': 'Luxury', 'product_id': 5.0}]

--------------------------------------------------
External knowledge that might be helpful: 
None
The table structure information is ({database name: {schema name: [table name]}}): 
{'BANK_SALES_TRADING': {'BANK_SALES_TRADING': ['INTEREST_MAP', 'INTEREST_METRICS', 'BITCOIN_PRICES', 'SHOPPING_CART_CAMPAIGN_IDENTIFIER', 'SHOPPING_CART_EVENT_IDENTIFIER', 'VEG_CAT', 'VEG_WHSLE_DF', 'BITCOIN_TRANSACTIONS', 'SHOPPING_CART_EVENTS', 'VEG_LOSS_RATE_DF', 'CUSTOMER_NODES', 'WEEKLY_SALES', 'BITCOIN_MEMBERS', 'CLEANED_WEEKLY_SALES', 'CUSTOMER_REGIONS', 'CUSTOMER_TRANSACTIONS', 'SHOPPING_CART_USERS', 'VEG_TXN_DF', 'SHOPPING_CART_PAGE_HIERARCHY']}}

Some few-shot examples after column exploration may be helpful:
Query:
-- 1) Preview a few raw customer transactions
--    (shows date, amount and type for quick context)
SELECT 
  "customer_id",
  "txn_date",
  "txn_amount",
  "txn_type"
FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
LIMIT 20;
Answer:
customer_id,txn_date,txn_amount,txn_type
429,2020-01-21,82,deposit
155,2020-01-10,712,deposit
398,2020-01-01,196,deposit
255,2020-01-14,563,deposit
185,2020-01-29,626,deposit
309,2020-01-13,995,deposit
312,2020-01-20,485,deposit
376,2020-01-03,706,deposit
188,2020-01-13,601,deposit
138,2020-01-11,520,deposit
373,2020-01-18,596,deposit
361,2020-01-12,797,deposit
169,2020-01-10,628,deposit
402,2020-01-05,435,deposit
60,2020-01-19,495,deposit
Query:
-- 2) List the different transaction types that exist
SELECT DISTINCT 
  "txn_type"
FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
LIMIT 20;
Answer:
txn_type
deposit
withdrawal
purchase
Query:
-- 3) For every customer, see their earliest and latest transaction dates
--    together with total amount that moved on record
WITH cte AS (
  SELECT
    "customer_id",
    MIN("txn_date") AS "min_txn_date",
    MAX("txn_date") AS "max_txn_date",
    SUM(CASE WHEN "txn_type" ILIKE 'deposit' 
             THEN "txn_amount" 
             ELSE -1 * "txn_amount" END) AS "net_amount"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
  GROUP BY "customer_id"
)
SELECT * FROM cte
LIMIT 20;
Answer:
customer_id,min_txn_date,max_txn_date,net_amount
309,2020-01-13,2020-04-09,-960
205,2020-01-02,2020-03-15,1067
287,2020-01-22,2020-04-11,-406
412,2020-01-01,2020-02-19,608
257,2020-01-20,2020-04-13,-976
378,2020-01-07,2020-03-21,1590
63,2020-01-06,2020-03-31,-3946
1,2020-01-02,2020-03-19,-640
46,2020-01-23,2020-04-20,104
406,2020-01-26,2020-04-10,2279
142,2020-01-16,2020-04-01,863
236,2020-01-27,2020-04-14,-100
162,2020-01-10,2020-02-08,784
172,2020-01-12,2020-03-16,-1038
Query:
-- 4) Compute a running balance per-customer per-day **only on the days a
--    transaction happened** (positive = deposit, negative = withdrawal)
WITH txns AS (
  SELECT
    "customer_id",
    TO_DATE("txn_date") AS "txn_date",
    CASE WHEN "txn_type" ILIKE 'deposit' 
         THEN "txn_amount" 
         ELSE -1 * "txn_amount" END           AS "signed_amount"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (
  SELECT
    "customer_id",
    "txn_date",
    SUM("signed_amount") 
      OVER (PARTITION BY "customer_id"
            ORDER BY "txn_date"
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
  FROM txns
)
SELECT * FROM running
LIMIT 20;
Answer:
customer_id,txn_date,running_balance
324,2020-01-04,538
324,2020-01-04,1021
324,2020-01-28,203
324,2020-02-09,967
324,2020-03-22,1152
324,2020-03-29,2139
324,2020-03-29,1470
468,2020-01-25,939
468,2020-01-29,39
468,2020-02-14,-863
468,2020-02-19,-155
468,2020-03-02,-115
468,2020-03-02,-141
468,2020-03-18,-917
Query:
-- 5) Expand every customer’s activity window into **all calendar days**
--    between their first & last transaction dates
WITH bounds AS (
  SELECT
    "customer_id",
    MIN(TO_DATE("txn_date")) AS "start_dt",
    MAX(TO_DATE("txn_date")) AS "end_dt"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
  GROUP BY "customer_id"
), calendar AS (
  SELECT
    b."customer_id",
    DATEADD(day, seq4(), b."start_dt") AS "calendar_dt"
  FROM bounds b,
       TABLE(GENERATOR(ROWCOUNT => 3650))          -- sufficient length
  WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
)
SELECT * FROM calendar
LIMIT 20;
Answer:
customer_id,calendar_dt
429,2020-01-21
155,2020-01-11
398,2020-01-03
255,2020-01-17
185,2020-02-02
309,2020-01-18
312,2020-01-26
376,2020-01-10
188,2020-01-21
138,2020-01-20
373,2020-01-28
169,2020-01-21
402,2020-01-17
383,2020-02-08
499,2020-01-16
441,2020-01-27
Query:
-- 6) Bring in the running balances (from Query-4) onto the full calendar,
--    then carry the previous balance forward to fill missing-day gaps
WITH txns AS (
  SELECT
    "customer_id",
    TO_DATE("txn_date") AS "txn_date",
    CASE WHEN "txn_type" ILIKE 'deposit' 
         THEN "txn_amount" 
         ELSE -1 * "txn_amount" END AS "signed_amount"
  FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), daily_running AS (
  SELECT
    "customer_id",
    "txn_date",
    SUM("signed_amount")
      OVER (PARTITION BY "customer_id"
            ORDER BY "txn_date"
            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
  FROM txns
), bounds AS (
  SELECT
    "customer_id",
    MIN("txn_date") AS "start_dt",
    MAX("txn_date") AS "end_dt"
  FROM daily_running
  GROUP BY "customer_id"
), calendar AS (
  SELECT
    b."customer_id",
    DATEADD(day, seq4(), b."start_dt") AS "calendar_dt"
  FROM bounds b,
       TABLE(GENERATOR(ROWCOUNT => 3650))
  WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (
  SELECT
    c."customer_id",
    c."calendar_dt",
    d."running_balance"
  FROM calendar c
  LEFT JOIN daily_running d
        ON c."customer_id" = d."customer_id"
       AND c."calendar_dt" = d."txn_date"
), filled AS (
  SELECT
    "customer_id",
    "calendar_dt",
    COALESCE(
      LAST_VALUE("running_balance") 
        IGNORE NULLS
        OVER (PARTITION BY "customer_id" 
              ORDER BY "calendar_dt"),
      0
    ) AS "daily_balance"
  FROM joined
)
SELECT * FROM filled
LIMIT 20;
Answer:
customer_id,calendar_dt,daily_balance
266,2020-01-20,651
12,2020-02-01,0
37,2020-03-04,848
321,2020-03-15,0
345,2020-03-08,-1586
266,2020-01-22,651
12,2020-02-03,0
37,2020-03-06,848
321,2020-03-17,0
345,2020-03-10,-1586
324,2020-01-16,0
367,2020-02-26,-467
366,2020-03-05,-783
224,2020-03-21,0
Query:
-- 7) Replace any negative daily balances with zero (per requirement)
WITH filled AS (  /* replicate Query-6 logic until daily balances step */ 
  SELECT
    j."customer_id",
    j."calendar_dt",
    COALESCE(
      LAST_VALUE(j."running_balance") 
        IGNORE NULLS
        OVER (PARTITION BY j."customer_id" 
              ORDER BY j."calendar_dt"),
      0
    ) AS "daily_balance"
  FROM (
        /* calendar-plus-running logic abbreviated for brevity */
        SELECT
          c."customer_id",
          c."calendar_dt",
          d."running_balance"
        FROM (
              /* calendar build */
              SELECT
                b."customer_id",
                DATEADD(day, seq4(), b."start_dt") AS "calendar_dt"
              FROM (
                    SELECT
                      "customer_id",
                      MIN(TO_DATE("txn_date")) AS "start_dt",
                      MAX(TO_DATE("txn_date")) AS "end_dt"
                    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
                    GROUP BY "customer_id"
              ) b,
              TABLE(GENERATOR(ROWCOUNT => 3650))
              WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
          ) c
          LEFT JOIN (
              /* running balance */
              SELECT
                "customer_id",
                TO_DATE("txn_date") AS "txn_date",
                SUM(CASE WHEN "txn_type" ILIKE 'deposit' 
                         THEN "txn_amount" 
                         ELSE -1 * "txn_amount" END)
                  OVER (PARTITION BY "customer_id"
                        ORDER BY TO_DATE("txn_date")
                        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS "running_balance"
              FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
          ) d
          ON c."customer_id" = d."customer_id" 
         AND c."calendar_dt" = d."txn_date"
    ) j
), clipped AS (
  SELECT
    "customer_id",
    "calendar_dt",
    CASE WHEN "daily_balance" < 0 THEN 0 ELSE "daily_balance" END AS "daily_balance"
  FROM filled
)
SELECT * FROM clipped
LIMIT 20;
Answer:
customer_id,calendar_dt,daily_balance
100,2020-01-09,1081
50,2020-02-17,0
199,2020-02-24,0
327,2020-03-05,239
344,2020-03-14,1270
100,2020-01-11,1081
50,2020-02-19,0
199,2020-02-26,0
327,2020-03-07,239
344,2020-03-16,1270
100,2020-01-15,1081
50,2020-02-23,0
199,2020-03-01,0
327,2020-03-11,239
Query:
--Description: 
-- Query 9 – re-creates the full daily-balance logic, derives each customer’s
-- monthly peak balance, then aggregates (sums) those peaks to give the total
-- peak balance per month for all customers.  Preview limited to 20 months.
WITH txns AS (
    SELECT
        "customer_id",
        TO_DATE("txn_date")                                   AS "txn_dt",
        CASE WHEN "txn_type" ILIKE 'deposit'
             THEN  "txn_amount"
             ELSE -1 * "txn_amount" END                      AS "signed_amt"
    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (
    SELECT
        "customer_id",
        "txn_dt",
        SUM("signed_amt") OVER (
             PARTITION BY "customer_id"
             ORDER BY "txn_dt"
             ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        )                                                   AS "run_bal"
    FROM txns
), bounds AS (
    SELECT
        "customer_id",
        MIN("txn_dt")                                       AS "start_dt",
        MAX("txn_dt")                                       AS "end_dt"
    FROM running
    GROUP BY "customer_id"
), cal AS (
    SELECT
        b."customer_id",
        DATEADD(day, seq4(), b."start_dt")                  AS "cal_dt"
    FROM bounds b,
         TABLE(GENERATOR(ROWCOUNT => 1000))
    WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (
    SELECT
        c."customer_id",
        c."cal_dt",
        r."run_bal"
    FROM cal c
    LEFT JOIN running r
           ON r."customer_id" = c."customer_id"
          AND r."txn_dt"      = c."cal_dt"
), filled AS (
    SELECT
        "customer_id",
        "cal_dt",
        COALESCE(
            LAST_VALUE("run_bal") IGNORE NULLS
              OVER (PARTITION BY "customer_id" ORDER BY "cal_dt"),
            0
        )                                                   AS "daily_bal"
    FROM joined
), clipped AS (
    SELECT
        "customer_id",
        "cal_dt",
        CASE WHEN "daily_bal" < 0 THEN 0 ELSE "daily_bal" END
                                                          AS "daily_bal_nonneg"
    FROM filled
), peak AS (
    SELECT
        "customer_id",
        TO_CHAR("cal_dt", 'YYYY-MM')                       AS "month_id",
        MAX("daily_bal_nonneg")                            AS "peak_bal"
    FROM clipped
    GROUP BY "customer_id", TO_CHAR("cal_dt", 'YYYY-MM')
)
SELECT
    "month_id",
    SUM("peak_bal")                                       AS "total_peak_balance"
FROM peak
GROUP BY "month_id"
ORDER BY "month_id"
LIMIT 20
Answer:
month_id,total_peak_balance
2020-01,5967
2020-02,5967
2020-03,5967
2020-04,4815
Query:
--Description: 
-- Query 10 – using the same logic, returns the customers who contributed to
-- a selected month’s peak-balance pool (example month: 2020-01) along with
-- each customer’s personal maximum daily balance in that month. Top 20 shown.
WITH txns AS (
    SELECT
        "customer_id",
        TO_DATE("txn_date")                                   AS "txn_dt",
        CASE WHEN "txn_type" ILIKE 'deposit'
             THEN  "txn_amount"
             ELSE -1 * "txn_amount" END                      AS "signed_amt"
    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
), running AS (
    SELECT
        "customer_id",
        "txn_dt",
        SUM("signed_amt") OVER (
             PARTITION BY "customer_id"
             ORDER BY "txn_dt"
             ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        )                                                   AS "run_bal"
    FROM txns
), bounds AS (
    SELECT
        "customer_id",
        MIN("txn_dt")                                       AS "start_dt",
        MAX("txn_dt")                                       AS "end_dt"
    FROM running
    GROUP BY "customer_id"
), cal AS (
    SELECT
        b."customer_id",
        DATEADD(day, seq4(), b."start_dt")                  AS "cal_dt"
    FROM bounds b,
         TABLE(GENERATOR(ROWCOUNT => 1000))
    WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
), joined AS (
    SELECT
        c."customer_id",
        c."cal_dt",
        r."run_bal"
    FROM cal c
    LEFT JOIN running r
           ON r."customer_id" = c."customer_id"
          AND r."txn_dt"      = c."cal_dt"
), filled AS (
    SELECT
        "customer_id",
        "cal_dt",
        COALESCE(
            LAST_VALUE("run_bal") IGNORE NULLS
              OVER (PARTITION BY "customer_id" ORDER BY "cal_dt"),
            0
        )                                                   AS "daily_bal"
    FROM joined
), clipped AS (
    SELECT
        "customer_id",
        "cal_dt",
        CASE WHEN "daily_bal" < 0 THEN 0 ELSE "daily_bal" END
                                                          AS "daily_bal_nonneg"
    FROM filled
), peak AS (
    SELECT
        "customer_id",
        TO_CHAR("cal_dt", 'YYYY-MM')                       AS "month_id",
        MAX("daily_bal_nonneg")                            AS "peak_bal"
    FROM clipped
    GROUP BY "customer_id", TO_CHAR("cal_dt", 'YYYY-MM')
)
SELECT
    "customer_id",
    "peak_bal"                                            AS "max_daily_balance"
FROM peak
WHERE "month_id" = '2020-01'
ORDER BY "max_daily_balance" DESC
LIMIT 20
Answer:
customer_id,max_daily_balance
468,939
378,0
195,0
180,0
308,0
Task: For each customer, calculate their daily balances for every day between their earliest and latest transaction dates, including days without transactions by carrying forward the previous day's balance. Treat any negative daily balances as zero. Then, for each month, determine the highest daily balance each customer had during that month. Finally, for each month, sum these maximum daily balances across all customers to obtain a monthly total.

Please think step by step and answer only one complete SQL in snowflake dialect in ```sql``` format.
SQL usage example: ```sql
SELECT "COLUMN_NAME" FROM DATABASE.SCHEMA.TABLE WHERE ... ``` (Adjust "DATABASE", "SCHEMA", and "TABLE" to match actual names, ensure all column names are enclosed in double quotations)
Here are some useful tips for answering:
When performing a UNION operation on many tables, ensure that all table names are explicitly listed. Union first and then add condition and selection. e.g. SELECT "col1", "col2" FROM (TABLE1 UNION ALL TABLE2) WHERE ...; Don't write sqls as (SELECT col1, col2 FROM TABLE1 WHERE ...) UNION ALL (SELECT col1, col2 FROM TABLE2 WHERE ...); Don't use ['-- Include all', '-- Omit', '-- Continue', '-- Union all', '-- ...', '-- List all', '-- Replace this', '-- Each table', '-- Add other'] to omit any table. Table names here: The table structure information is ({database name: {schema name: [table name]}}): 
{'BANK_SALES_TRADING': {'BANK_SALES_TRADING': ['INTEREST_MAP', 'INTEREST_METRICS', 'BITCOIN_PRICES', 'SHOPPING_CART_CAMPAIGN_IDENTIFIER', 'SHOPPING_CART_EVENT_IDENTIFIER', 'VEG_CAT', 'VEG_WHSLE_DF', 'BITCOIN_TRANSACTIONS', 'SHOPPING_CART_EVENTS', 'VEG_LOSS_RATE_DF', 'CUSTOMER_NODES', 'WEEKLY_SALES', 'BITCOIN_MEMBERS', 'CLEANED_WEEKLY_SALES', 'CUSTOMER_REGIONS', 'CUSTOMER_TRANSACTIONS', 'SHOPPING_CART_USERS', 'VEG_TXN_DF', 'SHOPPING_CART_PAGE_HIERARCHY']}}

When using ORDER BY xxx DESC, add NULLS LAST to exclude null records: ORDER BY xxx DESC NULLS LAST.
If the task description does not specify the number of decimal places, retain all decimals to four places.

[Self-refine]
2025-05-07 07:10:04 - Thread-615 (execute) - INFO - [Try to run SQL in self-refine]
```sql
/* -----------------------------------------------------------
   1) Build signed transactions (+ deposits, – withdrawals)
   2) Derive running balance per-customer per-txn-day
   3) Create a calendar of EVERY day between first & last txn
   4) Carry running balance forward to non-txn days
   5) Clip negatives to zero → daily balances
   6) Per month, take each customer’s MAX daily balance
   7) Sum those customer-maxima → monthly total peak balance
------------------------------------------------------------*/
WITH txns AS (   -- step-1
    SELECT
        "customer_id",
        TO_DATE("txn_date")                                          AS "txn_dt",
        CASE 
            WHEN LOWER("txn_type") = 'deposit'
                 THEN  "txn_amount"
                 ELSE -1 * "txn_amount"
        END                                                          AS "signed_amt"
    FROM BANK_SALES_TRADING.BANK_SALES_TRADING.CUSTOMER_TRANSACTIONS
),

running AS (     -- step-2
    SELECT
        "customer_id",
        "txn_dt",
        SUM("signed_amt") OVER (
                PARTITION BY "customer_id"
                ORDER BY       "txn_dt"
                ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
        )                                                           AS "run_bal"
    FROM txns
),

bounds AS (      -- first / last transaction dates
    SELECT
        "customer_id",
        MIN("txn_dt")                                               AS "start_dt",
        MAX("txn_dt")                                               AS "end_dt"
    FROM running
    GROUP BY "customer_id"
),

calendar AS (    -- step-3 : dense calendar rows
    SELECT
        b."customer_id",
        DATEADD(day, seq4(), b."start_dt")                          AS "cal_dt"
    FROM bounds b,
         TABLE(GENERATOR(ROWCOUNT => 5000))  -- long enough horizon
    WHERE DATEADD(day, seq4(), b."start_dt") <= b."end_dt"
),

joined AS (      -- align calendar with any txn-day balances
    SELECT
        c."customer_id",
        c."cal_dt",
        r."run_bal"
    FROM calendar c
    LEFT JOIN running r
           ON  r."customer_id" = c."customer_id"
          AND r."txn_dt"      = c."cal_dt"
),

filled AS (      -- step-4 : forward-fill balance
    SELECT
        "customer_id",
        "cal_dt",
        COALESCE(
            LAST_VALUE("run_bal") IGNORE NULLS
              OVER (PARTITION BY "customer_id"
                    ORDER BY      "cal_dt"),
            0
        )                                                           AS "daily_bal"
    FROM joined
),

clipped AS (     -- step-5 : zero-floor
    SELECT
        "customer_id",
        "cal_dt",
        CASE WHEN "daily_bal" < 0 THEN 0 ELSE "daily_bal" END       AS "daily_bal_nonneg"
    FROM filled
),

monthly_peak AS ( -- step-6
    SELECT
        "customer_id",
        TO_CHAR("cal_dt", 'YYYY-MM')                                AS "month_id",
        MAX("daily_bal_nonneg")                                     AS "peak_bal"
    FROM clipped
    GROUP BY
        "customer_id",
        TO_CHAR("cal_dt", 'YYYY-MM')
),

monthly_total_peak AS ( -- step-7
    SELECT
        "month_id",
        SUM("peak_bal")                                             AS "total_peak_balance"
    FROM monthly_peak
    GROUP BY "month_id"
)

SELECT
    "month_id",
    "total_peak_balance"
FROM monthly_total_peak
ORDER BY "month_id";
```
[Try to run SQL in self-refine]
2025-05-07 07:10:05 - Thread-615 (execute) - INFO - Total iteration counts: 0
